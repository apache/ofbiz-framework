<?xml version="1.0" encoding="UTF-8" ?>
<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->

<simple-methods xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
        xsi:noNamespaceSchemaLocation="http://www.ofbiz.org/dtds/simple-methods.xsd">
    <simple-method method-name="getOrderedSummaryInformation" short-description="Get Summary Information About Orders for a Customer">
        <if>
            <condition>
                <and>
                    <not><if-has-permission permission="ORDERMGR" action="_VIEW"/></not>
                    <if-compare-field field-name="parameters.partyId" operator="not-equals" to-field-name="userLogin.partyId"/>
                </and>
            </condition>
            <then>
                <string-to-list string="To get order summary information you must have the ORDERMGR_VIEW permission, or be logged in as the party to get the summary information for." list-name="error_list"/>
            </then>
        </if>
        <check-errors/>
        
        <if-not-empty field-name="monthsToInclude">
            <now-timestamp-to-env env-name="nowTimestamp"/>
            <call-bsh><![CDATA[
                calendar = java.util.Calendar.getInstance();
                calendar.setTimeInMillis(nowTimestamp.getTime());
                calendar.add(java.util.Calendar.MONTH, -monthsToInclude.intValue());
                parameters.put("fromDate", new Timestamp(calendar.getTimeInMillis()));
            ]]></call-bsh>
            <set from-field="nowTimestamp" field="parameters.thruDate"/>
        </if-not-empty>

        <if-empty field-name="parameters.roleTypeId">
            <set value="PLACING_CUSTOMER" field="parameters.roleTypeId"/>
        </if-empty>
        <if-empty field-name="parameters.orderTypeId">
            <set value="SALES_ORDER" field="parameters.orderTypeId"/>
        </if-empty>
        <if-empty field-name="parameters.statusId">
            <set value="ORDER_COMPLETED" field="parameters.statusId"/>
        </if-empty>

        <entity-condition entity-name="OrderHeaderAndRoleSummary" list-name="orderInfoList">
            <condition-list combine="and">
                <condition-expr field-name="partyId" operator="equals" env-name="parameters.partyId"/>
                <condition-expr field-name="roleTypeId" operator="equals" env-name="parameters.roleTypeId"/>
                <condition-expr field-name="orderTypeId" operator="equals" env-name="parameters.orderTypeId"/>
                <condition-expr field-name="statusId" operator="equals" env-name="parameters.statusId"/>
                <condition-expr field-name="orderDate" operator="greater-equals" env-name="parameters.fromDate" ignore-if-null="true"/>
                <condition-expr field-name="orderDate" operator="less-equals" env-name="parameters.thruDate" ignore-if-null="true"/>
            </condition-list>
            <select-field field-name="partyId"/>
            <select-field field-name="roleTypeId"/>
            <select-field field-name="totalGrandAmount"/>
            <select-field field-name="totalSubRemainingAmount"/>
            <select-field field-name="totalOrders"/>
        </entity-condition>

        <!-- first set the required OUT fields to zero -->
        <calculate field-name="plainDoubleZero" type="Double"><number value="0.0"/></calculate>
        <calculate field-name="plainLongZero" type="Long"><number value="0"/></calculate>
        <field-to-result field-name="plainDoubleZero" result-name="totalGrandAmount"/>
        <field-to-result field-name="plainDoubleZero" result-name="totalSubRemainingAmount"/>
        <field-to-result field-name="plainLongZero" result-name="totalOrders"/>

        <!-- because we specified the partyId and the roleTypeId, should only be one item in list returned -->
        <first-from-list list-name="orderInfoList" entry-name="orderInfo"/>
        <if-not-empty field-name="orderInfo">
            <field-to-result field-name="orderInfo.totalGrandAmount" result-name="totalGrandAmount"/>
            <field-to-result field-name="orderInfo.totalSubRemainingAmount" result-name="totalSubRemainingAmount"/>
            <field-to-result field-name="orderInfo.totalOrders" result-name="totalOrders"/>
        </if-not-empty>
    </simple-method>
    <simple-method method-name="createOrderShipment" short-description="Create OrderShipment">
        <set value="Create OrderShipment" field="operationName"/>
        <check-permission permission="ORDERMGR" action="_CREATE">
            <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunCreateOrderShipment"/>
        </check-permission>
        <check-errors/>

        <make-value value-name="newEntity" entity-name="OrderShipment"/>
        <set-pk-fields map-name="parameters" value-name="newEntity"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>

        <create-value value-name="newEntity"/>
    </simple-method>
    <simple-method method-name="deleteOrderShipment" short-description="Delete OrderShipment">
        <set value="Delete OrderShipment" field="operationName"/>
        <check-permission permission="ORDERMGR" action="_DELETE">
            <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunDeleteOrderShipment"/>
        </check-permission>
        <check-errors/>

        <entity-one entity-name="OrderShipment" value-name="lookedUpValue"/>
        <remove-value value-name="lookedUpValue"/>
    </simple-method>

    <!-- order requirement methods -->
    <simple-method method-name="createOrderRequirementCommitment" short-description="Create OrderRequirementCommitment">
        <!-- The permission checking is commented out to make this service work also when triggered from ecommerce orders -->
        <!--
        <check-permission permission="ORDERMGR" action="_CREATE">
            <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunCheckCreateOrderRequirementCommitment"/>
        </check-permission>
        <check-errors/>
        -->
        <make-value value-name="newEntity" entity-name="OrderRequirementCommitment"/>
        <set-pk-fields map-name="parameters" value-name="newEntity"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>
        <create-value value-name="newEntity"/>
    </simple-method>

    <simple-method method-name="createRequirementAndCommitment" short-description="create a requirement and commitment for it">
        <set value="PRODUCT_REQUIREMENT" field="inputMap.requirementTypeId"/>

        <!-- Include the facilityId corresponding to this order by looking up the ProductStore -->
        <entity-one entity-name="OrderHeader" value-name="orderHeader" auto-field-map="true"/>
        <get-related-one value-name="orderHeader" relation-name="ProductStore" to-value-name="productStore" use-cache="true"/>
        <if-not-empty field-name="productStore.inventoryFacilityId">
            <set from-field="productStore.inventoryFacilityId" field="inputMap.facilityId"/>
        </if-not-empty>

        <call-service service-name="createRequirement" in-map-name="inputMap">
            <result-to-field field-name="parameters.requirementId" result-name="requirementId"/>
        </call-service>

        <!-- create the OrderRequirementCommitment to record the Requirement created for an order item -->
        <set-service-fields to-map-name="orderReqCommitParams" service-name="createOrderRequirementCommitment" map-name="parameters"/>
        <call-service service-name="createOrderRequirementCommitment" in-map-name="orderReqCommitParams"/>

        <field-to-result field-name="parameters.requirementId" result-name="requirementId"/>
    </simple-method>

    <simple-method method-name="getProductFacilityAndQuantities" short-description="finds ProductFacility and QOH, ATP inventory for an inventoryItem">
        <!-- Get the ProductFacility for the minimum stock level -->
        <entity-one entity-name="ProductFacility" value-name="productFacility">
            <field-map env-name="inventoryItem.productId" field-name="productId"/>
            <field-map env-name="inventoryItem.facilityId" field-name="facilityId"/>
        </entity-one>

        <!-- Get the product's total quantityOnHand in the facility -->
        <set from-field="inventoryItem.productId" field="inputMap.productId"/>
        <set from-field="inventoryItem.facilityId" field="inputMap.facilityId"/>
        <call-service service-name="getInventoryAvailableByFacility" in-map-name="inputMap">
           <result-to-field field-name="quantityOnHandTotal" result-name="quantityOnHandTotal"/>
           <result-to-field field-name="availableToPromiseTotal" result-name="availableToPromiseTotal"/>
        </call-service>
        <clear-field field-name="inputMap"/>
    </simple-method>

    <simple-method method-name="getProductRequirementMethod" short-description="finds the requirement method for the product">
        <entity-one entity-name="OrderHeader" auto-field-map="true" value-name="order"/>
        <entity-one entity-name="Product" auto-field-map="true" value-name="product"/>
        <set from-field="product.requirementMethodEnumId" field="requirementMethodId"/>
        <if-empty field-name="requirementMethodId">
            <if>
                <condition>
                    <and>
                        <if-compare field-name="product.productTypeId" operator="not-equals" value="MARKETING_PKG_AUTO"/>
                        <if-compare field-name="product.productTypeId" operator="not-equals" value="DIGITAL_GOOD"/>
                    </and>
                </condition>
                <then>
                    <entity-one entity-name="ProductStore" value-name="productStore">
                        <field-map env-name="order.productStoreId" field-name="productStoreId"/>
                    </entity-one>
                    <set from-field="productStore.requirementMethodEnumId" field="requirementMethodId"/>
                </then>
            </if>
        </if-empty>
    </simple-method>

    <simple-method method-name="checkCreateOrderRequirement" short-description="Create OrderRequirementCommitment and Requirement">
        <check-permission permission="ORDERMGR" action="_CREATE">
            <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunCheckCreateOrderRequirement"/>
        </check-permission>
        <check-errors/>
        <call-simple-method method-name="getProductRequirementMethod"/>
        <if-compare field-name="order.orderTypeId" operator="equals" value="SALES_ORDER">
            <if-compare field-name="requirementMethodId" operator="equals" value="PRODRQM_AUTO">
                <!-- create the requirement -->
                <set from-field="parameters.productId" field="inputMap.productId"/>
                <set from-field="parameters.quantity" field="inputMap.quantity"/>
                <call-simple-method method-name="createRequirementAndCommitment"/>
            </if-compare>
        </if-compare>
    </simple-method>

    <simple-method method-name="checkCreateStockRequirementQoh" short-description="Create a Requirement if QOH goes under the minimum stock level">
        <check-permission permission="ORDERMGR" action="_CREATE">
            <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunCheckCreateStockRequirement"/>
        </check-permission>
        <check-errors/>

        <!-- If the service is triggered by the updateItemIssuance service, get the ItemIssuance by the passed itemIssuanceId -->
        <if-not-empty field-name="parameters.itemIssuanceId">
            <entity-one entity-name="ItemIssuance" auto-field-map="true" value-name="itemIssuance"/>
            <entity-one entity-name="InventoryItem" value-name="inventoryItem">
                <field-map env-name="itemIssuance.inventoryItemId" field-name="inventoryItemId"/>
            </entity-one>
        <else>
            <entity-one entity-name="InventoryItem" auto-field-map="true" value-name="inventoryItem"/>
        </else>
        </if-not-empty>

        <set from-field="inventoryItem.productId" field="parameters.productId"/>
        <call-simple-method method-name="getProductRequirementMethod"/>

        <if-compare field-name="requirementMethodId" operator="equals" value="PRODRQM_STOCK">
            <!-- get QOH, ATP quantities and find ProductFacility which has the minimum stock -->
            <call-simple-method method-name="getProductFacilityAndQuantities"/>

            <if-not-empty field-name="productFacility.minimumStock">
                <!-- No requirements are created if we are already under stock -->
                <if-compare-field field-name="quantityOnHandTotal" to-field-name="productFacility.minimumStock" operator="greater-equals" type="Double">
                    <calculate field-name="newQuantityOnHand">
                        <calcop field-name="quantityOnHandTotal" operator="subtract">
                            <calcop operator="get" field-name="parameters.quantity"/>
                        </calcop>
                    </calculate>
                    <!-- If this new issuance will cause the quantityOnHandTotal to go below the minimumStock, create a new requirement -->
                    <if-compare-field field-name="newQuantityOnHand" to-field-name="productFacility.minimumStock" operator="less" type="Double">
                        <set from-field="inventoryItem.productId" field="inputMap.productId"/>
                        <if-not-empty field-name="productFacility.reorderQuantity">
                            <set from-field="productFacility.reorderQuantity" field="inputMap.quantity"/>
                        <else>
                            <set from-field="parameters.quantity" field="inputMap.quantity"/>
                        </else>
                        </if-not-empty>
                        <set value="PRODUCT_REQUIREMENT" field="inputMap.requirementTypeId"/>
                        <call-service service-name="createRequirement" in-map-name="inputMap">
                            <result-to-field field-name="parameters.requirementId" result-name="requirementId"/>
                        </call-service>
                        <field-to-result field-name="parameters.requirementId" result-name="requirementId"/>
                    </if-compare-field>
                </if-compare-field>
            </if-not-empty>
        </if-compare>
    </simple-method>

    <simple-method method-name="checkCreateStockRequirementAtp" short-description="Create a Requirement if ATP goes under the minimum stock level">
        <check-permission permission="ORDERMGR" action="_CREATE">
            <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunCheckCreateStockRequirement"/>
        </check-permission>
        <check-errors/>

        <!-- assumes that inventoryItemId is one of the parameters and get the inventory item of the reservation -->
        <entity-one entity-name="InventoryItem" value-name="inventoryItem" auto-field-map="true"/>
        
        <!-- find the requirement method for this product -->
        <set from-field="inventoryItem.productId" field="parameters.productId"/>
        <call-simple-method method-name="getProductRequirementMethod"/>

        <if-compare field-name="requirementMethodId" operator="equals" value="PRODRQM_STOCK_ATP">
            <!-- get QOH, ATP quantities and find ProductFacility which has the minimum stock -->
            <call-simple-method method-name="getProductFacilityAndQuantities"/>

            <if-not-empty field-name="productFacility.minimumStock">
                <!-- No requirements are created if we are not under stock -->
                <!-- this service is supposed to be called after inventory is reserved, so inventory should have been updated already -->
                <if-compare-field field-name="availableToPromiseTotal" to-field-name="productFacility.minimumStock" operator="less" type="Double">
                    <calculate field-name="oldAvailableToPromise">
                        <calcop field-name="availableToPromiseTotal" operator="add">
                            <calcop operator="get" field-name="parameters.quantity"/>
                        </calcop>
                    </calculate>
                    <!-- If before this reservation the availableToPromiseTotal was over minimumStock, create a new requirement -->
                    <if-compare-field field-name="oldAvailableToPromise" to-field-name="productFacility.minimumStock" operator="greater-equals" type="Double">
                        <set from-field="inventoryItem.productId" field="inputMap.productId"/>
                        <if-not-empty field-name="productFacility.reorderQuantity">
                            <set from-field="productFacility.reorderQuantity" field="inputMap.quantity"/>
                        <else>
                            <set from-field="parameters.quantity" field="inputMap.quantity"/>
                        </else>
                        </if-not-empty>
                        <set value="PRODUCT_REQUIREMENT" field="inputMap.requirementTypeId"/>
                        <call-service service-name="createRequirement" in-map-name="inputMap">
                            <result-to-field field-name="parameters.requirementId" result-name="requirementId"/>
                        </call-service>
                        <field-to-result field-name="parameters.requirementId" result-name="requirementId"/>
                    </if-compare-field>
                </if-compare-field>
            </if-not-empty>
        </if-compare>
    </simple-method>

    <simple-method method-name="createRequirementFromItemATP" short-description="Create a Requirement for an item based on ATP inventory quantity and minimum">
        <check-permission permission="ORDERMGR" action="_CREATE">
            <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunCreateRequirementFromItemATP"/>
        </check-permission>
        <check-errors/>
        
        <!-- assumes that inventoryItemId is one of the parameters and get the inventory item of the reservation -->
        <entity-one entity-name="InventoryItem" value-name="inventoryItem" auto-field-map="true"/>
        
        <!-- find the requirement method for this product -->
        <set from-field="inventoryItem.productId" field="parameters.productId"/>
        <call-simple-method method-name="getProductRequirementMethod"/>

        <if-compare field-name="requirementMethodId" operator="equals" value="PRODRQM_ATP">
            <!-- get the ATP, QOH quantities and the product facility's minimum stock -->
            <call-simple-method method-name="getProductFacilityAndQuantities"/>
            
            <!-- are we below minimum stock?  this service is supposed to be called after inventory is reserved, so inventory should have been updated already -->
            <if-compare-field field-name="availableToPromiseTotal" to-field-name="productFacility.minimumStock" operator="less" type="Double">
                <!-- what is the right quantity?  It is the lesser of the actual quantity and the quantity required to bring us back up to minimum stock -->
                <calculate field-name="quantityShortfall">
                    <calcop field-name="productFacility.minimumStock" operator="subtract">
                        <calcop operator="get" field-name="availableToPromiseTotal"/>
                    </calcop>
                </calculate>
                <if-compare-field field-name="quantityShortfall" operator="less" type="Double" to-field-name="parameters.quantity">
                    <set from-field="quantityShortfall" field="inputMap.quantity"/>
                <else>
                    <set from-field="parameters.quantity" field="inputMap.quantity"/>
                </else>
                </if-compare-field>

                <!-- TODO: we're not supporting the reorderQuantity of the productFacility.  It seems that altering the requirement quantity
                    due to reorder quantities would affect the ability to link requirements and hence PO items back to the original order.
                    If we can support it while at the same time linking requirements back to the original sales order, that would be better. -->                
                <set from-field="parameters.productId" field="inputMap.productId"/>
                <set from-field="inventoryItem.facilityId" field="inputMap.facilityId"/>
                <call-simple-method method-name="createRequirementAndCommitment"/>
            </if-compare-field>
        </if-compare>
    </simple-method>

    <simple-method method-name="checkCreateProductRequirementForFacility" short-description="Create Requirements for all the products in a facility with QOH under the minimum stock level">
        <check-permission permission="ORDERMGR" action="_CREATE">
            <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunCheckCreateStockRequirement"/>
        </check-permission>
        <check-errors/>

        <entity-and entity-name="ProductFacility" list-name="products">
            <field-map env-name="parameters.facilityId" field-name="facilityId"/>
        </entity-and>

        <iterate list-name="products" entry-name="productFacility">
            <set from-field="productFacility.productId" field="parameters.productId"/>
            <call-simple-method method-name="getProductRequirementMethod"/>
            <if>
                <condition>
                    <or>
                        <if-compare field-name="requirementMethodId" operator="equals" value="PRODRQM_STOCK"/>
                        <if-compare field-name="requirementMethodId" operator="equals" value="PRODRQM_STOCK_ATP"/>
                    </or>
                </condition>
                <then>
                    <!-- get QOH, ATP and find ProductFacility which has the minimum stock -->

                    <if-not-empty field-name="productFacility.minimumStock">
                        <!-- Get the product's total quantityOnHand in the facility -->
                        <clear-field field-name="inputMap"/>
                        <set from-field="productFacility.productId" field="inputMap.productId"/>
                        <set from-field="productFacility.facilityId" field="inputMap.facilityId"/>
                        <call-service service-name="getInventoryAvailableByFacility" in-map-name="inputMap">
                           <result-to-field field-name="quantityOnHandTotal" result-name="quantityOnHandTotal"/>
                           <result-to-field field-name="availableToPromiseTotal" result-name="availableToPromiseTotal"/>
                        </call-service>

                        <if-compare field-name="requirementMethodId" operator="equals" value="PRODRQM_STOCK">
                            <set from-field="quantityOnHandTotal" field="currentQuantity"/>
                        <else>
                            <set from-field="availableToPromiseTotal" field="currentQuantity"/>
                        </else>
                        </if-compare>

                        <!-- No requirements are created if we are already under stock -->
                        <if-compare-field field-name="currentQuantity" to-field-name="productFacility.minimumStock" operator="less" type="Double">
                            <clear-field field-name="inputMap"/>
                            <set from-field="productFacility.productId" field="inputMap.productId"/>
                            <if-not-empty field-name="productFacility.reorderQuantity">
                                <set from-field="productFacility.reorderQuantity" field="inputMap.quantity" type="Double"/>
                            <else>
                                <set value="0" field="inputMap.quantity" type="Double"/>
                            </else>
                            </if-not-empty>

                            <calculate field-name="quantityShortfall">
                                <calcop field-name="productFacility.minimumStock" operator="subtract">
                                    <calcop operator="get" field-name="currentQuantity"/>
                                </calcop>
                            </calculate>
                            <if-compare-field field-name="inputMap.quantity" to-field-name="quantityShortfall" operator="less" type="Double">
                                <set from-field="quantityShortfall" field="inputMap.quantity" type="Double"/>
                            </if-compare-field>

                            <set value="PRODUCT_REQUIREMENT" field="inputMap.requirementTypeId"/>
                            <set from-field="parameters.facilityId" field="inputMap.facilityId"/>
                            <call-service service-name="createRequirement" in-map-name="inputMap">
                                <result-to-field field-name="requirementId" result-name="requirementId"/>
                            </call-service>
                            <log level="info" message="Requirement creted with id [${requirementId}] for product with id [${productFacility.productId}]."/>
                        </if-compare-field>
                    </if-not-empty>
                </then>
            </if>
        </iterate>
    </simple-method>

    <simple-method method-name="getNextOrderId" short-description="Get Next orderId">
        <!-- try to find PartyAcctgPreference for parameters.partyId, see if we need any special order number sequencing -->
        <entity-one entity-name="PartyAcctgPreference" value-name="partyAcctgPreference"/>
        <log level="info" message="In getNextOrderId partyId is [${parameters.partyId}], partyAcctgPreference: ${partyAcctgPreference}"/>
        
        <if>
            <condition>
                <if-compare field-name="partyAcctgPreference.orderSequenceEnumId" operator="equals" value="ODRSQ_ENF_SEQ"/>
            </condition>
            <then>
                <!-- <log level="info" message="In getNextOrderId sequence enum ODRSQ_ENF_SEQ"/> -->
                <!-- this is sequential sequencing, we can't skip a number, also it must be a unique sequence per partyIdFrom -->
                <if-not-empty field-name="partyAcctgPreference.lastOrderNumber">
                    <calculate field-name="partyAcctgPreference.lastOrderNumber" type="Long">
                        <calcop operator="add" field-name="partyAcctgPreference.lastOrderNumber"/>
                        <number value="1"/>
                    </calculate>
                    <else>
                        <calculate field-name="partyAcctgPreference.lastOrderNumber" type="Long"><number value="1"/></calculate>
                    </else>
                </if-not-empty>
                <store-value value-name="partyAcctgPreference"/>
                <set from-field="partyAcctgPreference.lastOrderNumber" field="orderIdTemp"/>
            </then>
            <else>
                <!-- <log level="info" message="In getNextOrderId sequence enum ODRSQ_STANDARD"/> -->
                <!-- default to the default sequencing: ODRSQ_STANDARD -->
                <set from-field="parameters.orderId" field="orderIdTemp"/>
                <if-empty field-name="orderIdTemp">
                    <sequenced-id-to-env sequence-name="OrderHeader" env-name="orderIdTemp"/>
                    <else>
                        <!-- check the provided ID --> 
                        <check-id field-name="orderIdTemp"/>
                        <check-errors/>
                    </else>
                </if-empty>
            </else>
        </if>

        <if-not-empty field-name="parameters.productStoreId">
            <entity-one entity-name="ProductStore" value-name="productStore"/>
        </if-not-empty>
        
        <!-- use orderIdTemp along with the orderIdPrefix to create the real ID -->
        <set field="orderId" value="${productStore.orderNumberPrefix}${partyAcctgPreference.orderIdPrefix}${orderIdTemp}"/>
        <field-to-result field-name="orderId" result-name="orderId"/>
    </simple-method>
    
    <simple-method method-name="createOrderHeader" short-description="Create OrderHeader">
        <set value="Create OrderHeader" field="operationName"/>
        <check-permission permission="ORDERMGR" action="_CREATE">
            <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunCreateOrderShipment"/>
        </check-permission>
        <check-errors/>

        <make-value value-name="newEntity" entity-name="OrderHeader"/>
        <sequenced-id-to-env sequence-name="OrderHeader" env-name="newEntity.orderId"/>
        <field-to-result field-name="newEntity.orderId" result-name="orderId"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>

        <create-value value-name="newEntity"/>
    </simple-method>
    <simple-method method-name="updateOrderHeader" short-description="Update OrderHeader">
        <set value="Update OrderHeader" field="operationName"/>
        <check-permission permission="ORDERMGR" action="_UPDATE">
            <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunCreateOrderShipment"/>
        </check-permission>
        <check-errors/>

        <entity-one entity-name="OrderHeader" value-name="orderHeader"/>
        <if-empty field-name="orderHeader">
            <add-error><fail-message message="ERROR: Cannot update specified contact info because it does not correspond to the specified work effort"/></add-error>
        </if-empty>
        <check-errors/>
        <set-nonpk-fields value-name="orderHeader" map-name="parameters"/>
        <store-value value-name="orderHeader"/>  
    </simple-method>

    <simple-method method-name="recreateOrderAdjustments" short-description="Auto create OrderAdjustments">
        <check-permission permission="ORDERMGR" action="_CREATE">
            <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunAutoCreateOrderAdjustments"/>
        </check-permission>
        <check-errors/>
        <entity-one entity-name="OrderHeader" value-name="order" auto-field-map="true"/>
        <!-- all existing promo order items are cancelled -->
        <get-related value-name="order" relation-name="OrderItem" list-name="orderItems"/>
        <iterate list-name="orderItems" entry-name="orderItem">
            <if>
                <condition>
                    <and>
                        <if-compare field-name="orderItem.isPromo" value="Y" operator="equals"/>
                        <if-compare field-name="orderItem.statusId" value="ITEM_CANCELLED" operator="not-equals"/>
                    </and>
                </condition>
                <then>
                    <clear-field field-name="cancelOrderItemInMap"/>
                    <set-service-fields service-name="cancelOrderItemNoActions" to-map-name="cancelOrderItemInMap" map-name="parameters"/>
                    <set from-field="orderItem.orderItemSeqId" field="cancelOrderItemInMap.orderItemSeqId"/>
                    <call-service service-name="cancelOrderItemNoActions" in-map-name="cancelOrderItemInMap"/>
                </then>
            </if>
        </iterate>

        <get-related value-name="order" relation-name="OrderAdjustment" list-name="orderAdjustments"/>

        <!-- Accumulate the total existing promotional adjustment -->
        <set field="existingOrderAdjustmentTotal" value="0" type="BigDecimal"/>        
        <iterate list-name="orderAdjustments" entry-name="orderAdjustment">
            <if>
                <condition>
                    <not><if-empty field-name="orderAdjustment.productPromoId"/></not>
                </condition>
                <then>
                    <calculate field-name="existingOrderAdjustmentTotal" decimal-scale="3">
                        <calcop operator="add">
                            <calcop operator="get" field-name="orderAdjustment.amount"/>
                            <calcop operator="get" field-name="existingOrderAdjustmentTotal"/>
                        </calcop>
                    </calculate>
                </then>
            </if>
        </iterate>

        <!-- Recalculate the promotions for the order -->
        <set-service-fields service-name="loadCartFromOrder" to-map-name="loadCartFromOrderInMap" map-name="parameters"/>
        <set value="true" field="loadCartFromOrderInMap.skipInventoryChecks" type="Boolean"/>
        <set value="true" field="loadCartFromOrderInMap.skipProductChecks" type="Boolean"/>
        <call-service service-name="loadCartFromOrder" in-map-name="loadCartFromOrderInMap">
            <result-to-field result-name="shoppingCart" field-name="cart"/>
        </call-service>
        <call-object-method obj-field-name="cart" method-name="items" ret-field-name="items"/>
        <iterate list-name="items" entry-name="item">
            <call-object-method obj-field-name="item" method-name="getOrderItemSeqId" ret-field-name="orderItemSeqId"/>
            <if-empty field-name="orderItemSeqId">
                <!-- this is a new (promo) item -->
                <!-- a new order item is created -->
                <make-value value-name="newOrderItem" entity-name="OrderItem"/>
                <set field="newOrderItem.orderId" from-field="parameters.orderId"/>
                <call-object-method obj-field-name="item" method-name="getItemType" ret-field-name="newOrderItem.orderItemTypeId"/>
                <call-object-method obj-field-name="item" method-name="getSelectedAmount" ret-field-name="newOrderItem.selectedAmount"/>
                <call-object-method obj-field-name="item" method-name="getBasePrice" ret-field-name="newOrderItem.unitPrice"/>
                <call-object-method obj-field-name="item" method-name="getListPrice" ret-field-name="newOrderItem.unitListPrice"/>
                <call-object-method obj-field-name="item" method-name="getName" ret-field-name="newOrderItem.itemDescription"/>
                <call-object-method obj-field-name="item" method-name="getStatusId" ret-field-name="newOrderItem.statusId"/>
                <call-object-method obj-field-name="item" method-name="getProductId" ret-field-name="newOrderItem.productId"/>
                <call-object-method obj-field-name="item" method-name="getQuantity" ret-field-name="newOrderItem.quantity"/>
                <set field="newOrderItem.isModifiedPrice" value="N"/>
                <set field="newOrderItem.isPromo" value="Y"/>
                <if-empty field-name="newOrderItem.statusId">
                    <set field="newOrderItem.statusId" value="ITEM_CREATED"/>
                </if-empty>
                <make-next-seq-id value-name="newOrderItem" seq-field-name="orderItemSeqId"/>
                <create-value value-name="newOrderItem"/>
                <!-- and the orderItemSeqId is assigned to the shopping cart item-->
                <call-object-method obj-field-name="item" method-name="setOrderItemSeqId">
                    <field field-name="newOrderItem.orderItemSeqId" type="String"/>
                </call-object-method>
            </if-empty>
        </iterate>
        <call-object-method obj-field-name="cart" method-name="makeAllAdjustments" ret-field-name="adjustments"/>

        <!-- Accumulate the new promotion total from the recalculated promotion adjustments -->
        <set field="newOrderAdjustmentTotal" value="0" type="BigDecimal"/>        
        <iterate list-name="adjustments" entry-name="adjustment">
            <if>
                <condition>
                    <not><if-empty field-name="orderAdjustment.productPromoId"/></not>
                </condition>
                <then>
                    <calculate field-name="newOrderAdjustmentTotal" decimal-scale="3">
                        <calcop operator="add">
                            <calcop operator="get" field-name="adjustment.amount"/>
                            <calcop operator="get" field-name="newOrderAdjustmentTotal"/>
                        </calcop>
                    </calculate>
                </then>
            </if>
        </iterate>
        
        <!-- Determine the difference between existing and new promotion adjustment totals, if any -->
        <calculate field-name="orderAdjustmentTotalDifference" decimal-scale="3" type="BigDecimal">
            <calcop operator="subtract" field-name="newOrderAdjustmentTotal">
                <calcop operator="get" field-name="existingOrderAdjustmentTotal"/>
            </calcop>
        </calculate>
        
        <!-- If the total has changed, create an OrderAdjustment to reflect the fact -->
        <if-compare field-name="orderAdjustmentTotalDifference" value="0" operator="not-equals" type="BigDecimal">
            <set field="createOrderAdjContext.orderAdjustmentTypeId" value="PROMOTION_ADJUSTMENT"/>
            <set field="createOrderAdjContext.orderId" from-field="parameters.orderId"/>
            <set field="createOrderAdjContext.orderItemSeqId" value="_NA_"/>
            <set field="createOrderAdjContext.shipGroupSeqId" value="_NA_"/>
            <set field="createOrderAdjContext.description" value="Adjustment due to order change"/>
            <set field="createOrderAdjContext.amount" from-field="orderAdjustmentTotalDifference" type="Double"/>
            <call-service service-name="createOrderAdjustment" in-map-name="createOrderAdjContext" include-user-login="true"/>
            <check-errors/>        
        </if-compare>
    </simple-method>
    
    <!--UpdateOrderContactMech-->
    
     <simple-method method-name="updateOrderContactMech" short-description="Update OrderContactMech">
        <check-permission permission="ORDERMGR" action="_UPDATE">
           <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunUpdateOrderContactMech"/>
        </check-permission>
        <check-errors/>
        <make-value value-name="orderContactMechMap" entity-name="OrderContactMech"/>
        <set-pk-fields map-name="parameters" value-name="orderContactMechMap"/>
        <set from-field="parameters.orderId" field="inputMap.orderId"/>
        <set from-field="parameters.contactMechPurposeTypeId" field="inputMap.contactMechPurposeTypeId"/>
        <set from-field="parameters.contactMechId" field="inputMap.contactMechId"/>
        <if-compare value="SHIPPING_LOCATION" field-name="parameters.contactMechPurposeTypeId" operator="equals">
           <if-compare value="parameters.oldContactMechId" field-name="parameters.contactMechId" operator="not-equals">
           <set field="orderItemShipGroupMap.orderId" from-field="parameters.orderId"/>
           <set field="orderItemShipGroupMap.contactMechId" from-field="parameters.oldContactMechId"/>    
           <find-by-and entity-name="OrderItemShipGroup" list-name="shipGroupList" map-name="orderItemShipGroupMap"/>
           <if-not-empty field-name="shipGroupList">
              <iterate list-name="shipGroupList" entry-name="shipGroup">
                 <set field="inputMap.shipGroupSeqId" from-field="shipGroup.shipGroupSeqId"/>  
                 <set field="inputMap.shipmentMethod" value="${shipGroup.shipmentMethodTypeId}@${shipGroup.carrierPartyId}"/>
                 <set field="inputMap.oldContactMechId" from-field="parameters.oldContactMechId"/>
                 <set-service-fields to-map-name="orderItemShipGroupMap" service-name="updateOrderItemShipGroup" map-name="inputMap"/>
                 <call-service service-name="updateOrderItemShipGroup" in-map-name="orderItemShipGroupMap" include-user-login="true"/>
              </iterate>
           </if-not-empty>
           </if-compare> 
        <else>
        <find-by-and entity-name="OrderContactMech" map-name="inputMap" list-name="orderContactMechList"/>
        <!-- If orderContactMechList value is null then create new entry in OrderContactMech entity-->
        <if-empty field-name="orderContactMechList">
            <set-service-fields service-name="createOrderContactMech" map-name="parameters" to-map-name="createOrderContactMechMap"/>
            <call-service service-name="createOrderContactMech" in-map-name="createOrderContactMechMap" include-user-login="true"/>
            <set from-field="parameters.orderId" field="orderContactMechLookupMap.orderId"/>
            <set from-field="parameters.oldContactMechId" field="orderContactMechLookupMap.contactMechId"/>
            <set from-field="parameters.contactMechPurposeTypeId" field="orderContactMechLookupMap.contactMechPurposeTypeId"/>
            <set-service-fields service-name="removeOrderContactMech" map-name="orderContactMechLookupMap" to-map-name="removeOrderContactMechMap"/>
            <call-service service-name="removeOrderContactMech" in-map-name="removeOrderContactMechMap" include-user-login="true"/>
        </if-empty>    
        <store-value value-name="orderContactMechMap"/>
        </else>         
        </if-compare>     
     </simple-method>
    
    <!-- OrderItemShipGroup -->
    <simple-method method-name="updateOrderItemShipGroup" short-description="Update OrderItemShipGroup">
        <check-permission permission="ORDERMGR" action="_UPDATE">
            <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunUpdateOrderItemShipGroup"/>
        </check-permission>
        <check-errors/>
        <make-value value-name="lookupPKMap" entity-name="OrderItemShipGroup"/>
        <set-pk-fields map-name="parameters" value-name="lookupPKMap"/>
        <find-by-primary-key entity-name="OrderItemShipGroup" map-name="lookupPKMap" value-name="lookedUpValue"/>
        <!-- splitting shipmentMethod request parameter value that contains "@" symbol 
             into "shipmentMethodTypeId" and "carrierPartyId".          
        -->
        <call-bsh><![CDATA[
            shipmentMethod = parameters.get("shipmentMethod");
            if(shipmentMethod != null){
               parameters.put("shipmentMethodTypeId", shipmentMethod.substring(0, shipmentMethod.indexOf("@")));
               parameters.put("carrierPartyId", shipmentMethod.substring(shipmentMethod.indexOf("@")+1));
            }
        ]]></call-bsh>
        <set-nonpk-fields map-name="parameters" value-name="lookedUpValue"/>
        
        <set from-field="parameters.orderId" field="inputMap.orderId"/>
        <set from-field="parameters.contactMechPurposeTypeId" field="inputMap.contactMechPurposeTypeId"/>
        <set from-field="parameters.contactMechId" field="inputMap.contactMechId"/>
        <find-by-and entity-name="OrderContactMech" map-name="inputMap" list-name="orderContactMechList"/>
        <!-- If orderContactMechList value is null then create new entry in OrderContactMech entity-->
        <if-empty field-name="orderContactMechList">
            <set-service-fields service-name="createOrderContactMech" map-name="parameters" to-map-name="createOrderContactMechMap"/>
            <call-service service-name="createOrderContactMech" in-map-name="createOrderContactMechMap" include-user-login="true"/>
        </if-empty>    
        <store-value value-name="lookedUpValue"/>
        <!-- Remove the old values from OrderContactMech entity with the help of oldContactMechId -->
        <set from-field="parameters.orderId" field="shipGroupLookupMap.orderId"/>
        <set from-field="parameters.oldContactMechId" field="shipGroupLookupMap.contactMechId"/>
        <find-by-and entity-name="OrderItemShipGroup" map-name="shipGroupLookupMap" list-name="orderItemShipGroupList"/>
        <if-empty field-name="orderItemShipGroupList">
            <set from-field="parameters.orderId" field="inputMap.orderId"/>
            <set from-field="parameters.contactMechPurposeTypeId" field="inputMap.contactMechPurposeTypeId"/>
            <set from-field="parameters.oldContactMechId" field="inputMap.contactMechId"/>
            <find-by-and entity-name="OrderContactMech" map-name="inputMap" list-name="orderContactMechList"/>
            <set-service-fields service-name="createOrderContactMech" map-name="inputMap" to-map-name="removeOrderContactMechMap"/>
            <call-service service-name="removeOrderContactMech" in-map-name="removeOrderContactMechMap" include-user-login="true"/>
        </if-empty>
    </simple-method>

    <simple-method method-name="getOrderItemShipGroupEstimatedShipDate" short-description="Compute and return the OrderItemShipGroup estimated ship date based on the associated items.">
        <entity-one entity-name="OrderItemShipGroup" value-name="orderItemShipGroup"/>
        <if-compare field-name="orderItemShipGroup.maySplit" operator="equals" value="Y">
            <set field="orderByList[]" value="+promisedDatetime"/>
        <else>
            <set field="orderByList[]" value="-promisedDatetime"/>
        </else>
        </if-compare>
        <get-related value-name="orderItemShipGroup" relation-name="OrderItemShipGrpInvRes" list-name="orderItemShipGroupInvResList" order-by-list-name="orderByList"/>
        <first-from-list entry-name="orderItemShipGroupInvRes" list-name="orderItemShipGroupInvResList"/>
        <field-to-result field-name="orderItemShipGroupInvRes.promisedDatetime" result-name="estimatedShipDate"/>
    </simple-method>

    <simple-method method-name="createOrderContactMech" short-description="Create OrderContactMech">
        <check-permission permission="ORDERMGR" action="_CREATE">
            <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunCreateOrderContactMech"/>
        </check-permission>
        <check-errors/>
        <make-value value-name="newEntity" entity-name="OrderContactMech"/>
        <set-pk-fields map-name="parameters" value-name="newEntity"/>
        <create-value value-name="newEntity"/>
    </simple-method>

    <simple-method method-name="removeOrderContactMech" short-description="Remove OrderContactMech">
        <check-permission permission="ORDERMGR" action="_DELETE">
            <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunRemoveOrderContactMech"/>
        </check-permission>
        <check-errors/>
        <entity-one entity-name="OrderContactMech" value-name="lookedUpValue"/>
        <remove-value value-name="lookedUpValue"/>
    </simple-method>
    
    <simple-method method-name="updateOrderNote" short-description="Update OrderNote">
        <check-permission permission="ORDERMGR" action="_UPDATE">
            <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunUpdateOrderNote"/>
        </check-permission>
        <check-errors/>
        <entity-one entity-name="OrderHeaderNote" value-name="orderHeaderNote"/>
        <set-nonpk-fields value-name="orderHeaderNote" map-name="parameters"/>
        <store-value value-name="orderHeaderNote"/>  
    </simple-method>
        
    <simple-method method-name="createOrderTerm" short-description="Create an OrderTerm">
        <check-permission permission="ORDERMGR" action="_CREATE">
            <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunCreateOrderTerm"/>
        </check-permission>
        <check-errors/>

        <make-value value-name="newEntity" entity-name="OrderTerm"/>
        <set-pk-fields map-name="parameters" value-name="newEntity"/>
        <set value="_NA_" set-if-empty="true" field="newEntity.orderItemSeqId"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>

        <create-value value-name="newEntity"/>
    </simple-method>
    <simple-method method-name="updateOrderTerm" short-description="Update OrderTerm">
        <check-permission permission="ORDERMGR" action="_DELETE">
            <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunUpdateOrderTerm"/>
        </check-permission>
        <check-errors/>

        <entity-one entity-name="OrderTerm" value-name="lookedUpValue"/>
        <set-nonpk-fields map-name="parameters" value-name="lookedUpValue"/>
        <store-value value-name="lookedUpValue"/>
    </simple-method>
    <simple-method method-name="removeOrderTerm" short-description="Remove OrderTerm">
        <check-permission permission="ORDERMGR" action="_DELETE">
            <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunRemoveOrderTerm"/>
        </check-permission>
        <check-errors/>

        <entity-one entity-name="OrderTerm" value-name="lookedUpValue"/>
        <remove-value value-name="lookedUpValue"/>
    </simple-method>
    
    <simple-method method-name="addPaymentMethodToOrder" short-description="Create an PaymentMethodToOrder">
        <check-permission permission="ORDERMGR" action="_CREATE">
            <fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunAddPaymentMethodToOrder"/>
        </check-permission>
        <check-errors/>
        <set field="inputMap.paymentMethodId" from-field="parameters.paymentMethodId"/>
        <set field="inputMap.maxAmount" from-field="parameters.maxAmount"/>
        <set field="inputMap.orderId" from-field="parameters.orderId"/>
        <entity-one entity-name="PaymentMethod" value-name="paymentMethod">
            <field-map field-name="paymentMethodId" env-name="parameters.paymentMethodId"/>
        </entity-one>
        <set field="inputMap.paymentMethodTypeId" from-field="paymentMethod.paymentMethodTypeId"/>
        <!--In this method we calls createOrderPaymentPreference and returns orderPaymentPreferenceId field to authOrderPaymentPreference -->       
        <call-service service-name="createOrderPaymentPreference" in-map-name="inputMap" include-user-login="true">
           <result-to-field field-name="parameters.orderPaymentPreferenceId" result-name="orderPaymentPreferenceId"/> 
        </call-service>   
        <field-to-result field-name="parameters.orderPaymentPreferenceId" result-name="orderPaymentPreferenceId"/>
    </simple-method>
    
</simple-methods>

