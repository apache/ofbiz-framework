<?xml version="1.0" encoding="UTF-8" ?>
<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->

<simple-methods xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="http://www.ofbiz.org/dtds/simple-methods.xsd">
    <simple-method method-name="createReturnHeader" short-description="Create a ReturnHeader">
        <now-timestamp-to-env env-name="nowTimestamp"/>

        <if>
            <condition>
                <and>
                    <not><if-has-permission permission="ORDERMGR" action="_CREATE"/></not>
                    <not><if-compare-field field-name="partyId" map-name="userLogin" operator="equals" to-field-name="fromPartyId" to-map-name="parameters"/></not>
                </and>
            </condition>
            <then>
                <add-error><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunCreateReturnHeader"/></add-error>
            </then>
        </if>

        <if-empty field-name="parameters.toPartyId">
            <!-- no toPartyId was specified.  use destination facility to determine the party of the return -->
            <if-not-empty field-name="parameters.destinationFacilityId">
                <entity-one entity-name="Facility" value-name="destinationFacility" auto-field-map="false">
                    <field-map field-name="facilityId" env-name="parameters.destinationFacilityId"/>
                </entity-one>
                <set from-field="destinationFacility.ownerPartyId" field="parameters.toPartyId"/>
            </if-not-empty>
        <else>
            <!-- make sure that the party to return to is an INTERNAL_ORGANIZATIO or stop
            TODO: if we want to implement returns to vendor later, simply change this to make sure that EITHER fromPartyId or toPartyId
            is an internal organization, and possibly also do a security check on the user -->
            <entity-one entity-name="PartyRole" value-name="partyRole" use-cache="true" auto-field-map="false">
                <field-map field-name="partyId" env-name="parameters.toPartyId"/>
                <field-map field-name="roleTypeId" value="INTERNAL_ORGANIZATIO"/>
            </entity-one>
            <if-empty field-name="partyRole">
                <add-error><fail-message message="Error: a return must be to a party in the role of internal organization"/></add-error>
            </if-empty>
         </else>
        </if-empty>
        <check-errors/>

        <!-- check the needs (auto) inventory receive flag (default to no) -->
        <if-empty field-name="parameters.needsInventoryReceive">
            <set field="parameters.needsInventoryReceive" value="N"/>
        </if-empty>

        <make-value value-name="newEntity" entity-name="ReturnHeader"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>

        <!-- If PartyAcctgPreference.useInvoiceIdForReturns is Y, get the ID from the getNextInvoiceId service -->
        <entity-one entity-name="PartyAcctgPreference" value-name="partyAcctgPreference" auto-field-map="false">
            <field-map field-name="partyId" env-name="parameters.toPartyId"/>
        </entity-one>
        <if-compare field-name="partyAcctgPreference.useInvoiceIdForReturns" operator="equals" value="Y">
            <set field="getNextInvoiceIdMap.partyId" from-field="parameters.toPartyId"/>
            <call-service service-name="getNextInvoiceId" in-map-name="getNextInvoiceIdMap">
                <result-to-field result-name="invoiceId" field-name="newEntity.returnId"/>
            </call-service>

            <else>
                <sequenced-id-to-env sequence-name="ReturnHeader" env-name="newEntity.returnId"/>
            </else>
        </if-compare>
        <field-to-result field-name="newEntity.returnId" result-name="returnId"/>

        <if>
            <condition>
                <not><if-has-permission permission="ORDERMGR" action="_CREATE"/></not>
            </condition>
            <then>
                <set field="newEntity.statusId" value="RETURN_REQUESTED"/>
                <set from-field="nowTimestamp" field="newEntity.entryDate"/>
            </then>
        </if>

        <if-empty field-name="newEntity.entryDate">
            <set from-field="nowTimestamp" field="newEntity.entryDate"/>
        </if-empty>

        <if-empty field-name="newEntity.statusId">
            <set value="RETURN_REQUESTED" field="newEntity.statusId"/>
        </if-empty>
        <set field="newEntity.createdBy" from-field="userLogin.userLoginId"/>

        <create-value value-name="newEntity"/>
        <set field="responseMessage" value="Return Request #${newEntity.returnId} was created successfully."/>
        <field-to-result field-name="responseMessage" result-name="successMessage"/>
    </simple-method>
    <simple-method method-name="updateReturnHeader" short-description="Update a ReturnHeader">
        <check-permission permission="ORDERMGR" action="_UPDATE"><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunUpdateReturnHeader"/></check-permission>
        <check-errors/>

        <set from-field="parameters.returnId" field="lookupPKMap.returnId"/>
        <find-by-primary-key entity-name="ReturnHeader" map-name="lookupPKMap" value-name="returnHeader"/>

        <!-- test the total return amount vs the total order amount -->
        <if-compare field-name="parameters.statusId" value="RETURN_ACCEPTED" operator="equals">
            <!-- get the list of ReturnItems.  Note: return may be assosicated with many different orders -->
            <entity-condition entity-name="ReturnItem" list-name="returnItems" distinct="true">
                <condition-expr field-name="returnId" operator="equals" env-name="returnHeader.returnId"/>
            </entity-condition>
            <!-- this block is for debugging and can be removed later -->
            <log level="verbose" message="Items and adjustments for return ${returnHeader.returnId}"/>
            <entity-condition entity-name="ReturnAdjustment" list-name="returnAdjustments" distinct="true">
                <condition-expr field-name="returnId" operator="equals" env-name="returnHeader.returnId"/>
            </entity-condition>
            <iterate entry-name="returnItem" list-name="returnItems">
                <log level="verbose" message="item: ${returnItem.returnItemSeqId} ${returnItem.returnItemTypeId} [${returnItem.description}] ${returnItem.productId} ${returnItem.returnQuantity} ${returnItem.returnPrice}"/>
            </iterate>
            <iterate entry-name="returnAdjustment" list-name="returnAdjustments">
                <log level="verbose" message="adjustment: ${returnAdjustment.returnItemSeqId} ${returnAdjustment.returnAdjustmentTypeId} [${returnAdjustment.description}] ${returnAdjustment.amount}"/>
            </iterate>
            <!-- debugging block -->

            <!-- this is used to make sure we don't return a negative amount -->
            <calculate field-name="returnTotalAmount"><number value="0.0"/></calculate>

            <!-- check them all to make sure that the return total does not exceed order total.  -->
            <iterate entry-name="returnItem" list-name="returnItems">

               <!-- tally up the return total amount -->
               <calculate field-name="returnTotalAmount">
                   <calcop field-name="returnTotalAmount" operator="add">
                       <calcop operator="multiply">
                            <calcop operator="get" field-name="returnPrice" map-name="returnItem"/>
                            <calcop operator="get" field-name="returnQuantity" map-name="returnItem"/>
                        </calcop>
                   </calcop>
                </calculate>

                <!-- compare return vs order total -->
                <if-not-empty field-name="returnItem.orderId">
                    <set field="returnTotalCtx.orderId" from-field="returnItem.orderId"/>
                    <!-- no adjustment needed: adjustment is passed in to calculate the effect of an additional item on return total.  -->
                    <calculate field-name="returnTotalCtx.adjustment" type="BigDecimal"><number value="0.0"/></calculate>
                    <call-service service-name="getOrderAvailableReturnedTotal" in-map-name="returnTotalCtx">
                        <result-to-field result-name="availableReturnTotal" field-name="availableReturnTotal"/>
                        <result-to-field result-name="returnTotal" field-name="returnTotal"/>
                        <result-to-field result-name="orderTotal" field-name="orderTotal"/>
                    </call-service>
                    <log level="info" message="Available amount for return on order #${returnItem.orderId} is [${availableReturnTotal}] (orderTotal = [${orderTotal}] - returnTotal = [${returnTotal}]"/>

                    <if-compare field-name="availableReturnTotal" operator="less" value="-0.01" type="BigDecimal">
                        <add-error><fail-property resource="OrderErrorUiLabels" property="OrderReturnPriceCannotExceedTheOrderTotal"/></add-error>
                    </if-compare>
                    <check-errors/>
                    <else>
                        <log level="info" message="Not an order based returnItem; unable to check valid amounts!"/>
                    </else>
                </if-not-empty>
            </iterate>

            <entity-and entity-name="ReturnAdjustment" list-name="returnAdjustments">
                <field-map field-name="returnId" env-name="returnHeader.returnId"/>
            </entity-and>
            <iterate entry-name="returnAdjustment" list-name="returnAdjustments">
                <calculate field-name="returnTotalAmount">
                         <calcop field-name="returnTotalAmount" operator="add">
                             <calcop operator="get" field-name="amount" map-name="returnAdjustment"/>
                         </calcop>
                  </calculate>
            </iterate>
            <if-compare field-name="returnTotalAmount" operator="less" value="0" type="Double">
                <add-error><fail-property resource="OrderErrorUiLabels" property="OrderReturnTotalCannotLessThanZero"/></add-error>
            </if-compare>
            <check-errors/>
        </if-compare>

        <field-to-result field-name="returnHeader.statusId" result-name="currentStatusId"/>
        <set-nonpk-fields map-name="parameters" value-name="returnHeader"/>
        <store-value value-name="returnHeader"/>
    </simple-method>

    <simple-method method-name="createReturnItem" short-description="Create Return Item">
        <set field="lookupPKMap.returnId" from-field="parameters.returnId"/>
        <find-by-primary-key entity-name="ReturnHeader" map-name="lookupPKMap" value-name="returnHeader"/>

        <if>
          <condition>
            <and>
              <not><if-has-permission permission="ORDERMGR" action="_CREATE"/></not>
              <not><if-compare-field field-name="partyId" map-name="userLogin" operator="equals" to-field-name="fromPartyId" to-map-name="returnHeader"/></not>
            </and>
          </condition>
          <then>
            <add-error><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunCreateReturnItem"/></add-error>
          </then>
        </if>
        <check-errors/>

        <if-empty field-name="returnItemTypeId"  map-name="parameters">
            <if-not-empty field-name="returnItemMapKey" map-name="parameters">
                <!-- find the item mapping -->
            </if-not-empty>
        </if-empty>

        <if-empty field-name="returnItemTypeId" map-name="parameters">
            <add-error><fail-message message="Return Item Type is not defined for this item; or no mapping was found."/></add-error>
            <check-errors/>
        </if-empty>

        <if-compare field-name="returnQuantity" map-name="parameters" operator="equals" value="0" type="Double">
            <add-error><fail-property resource="OrderErrorUiLabels" property="OrderNoReturnQuantityAvailablePreviousReturnsMayExist"/></add-error>
            <check-errors/>
        </if-compare>

        <!-- setup some default values for protection -->
        <set field="returnableQuantity" value="0" type="Double"/>
        <set field="returnablePrice" value="0" type="Double"/>

        <!-- if an orderItemSeqId  is provided, then find the corresponding orderItem  -->
        <if-not-empty field-name="parameters.orderItemSeqId">
            <make-value value-name="itemLookup" entity-name="OrderItem"/>
            <set-pk-fields map-name="parameters" value-name="itemLookup"/>
            <if-not-empty field-name="parameters.orderItemSeqId">
                <find-by-primary-key entity-name="OrderItem" value-name="orderItem" map-name="itemLookup"/>
                <log level="info" message="Return item is an OrderItem - ${orderItem.orderItemSeqId}"/>
            </if-not-empty>
        </if-not-empty>

        <!-- get the returnableQuantity and returnablePrice: for orderItems, it's found by getReturnableQuantity; for adjustments,
             either order adjustments or manual adjustments, it's always 1 and based on input parameter -->
        <if-not-empty field-name="orderItem">
            <set field="serviceContext.orderItem" from-field="orderItem"/>
            <call-service service-name="getReturnableQuantity" in-map-name="serviceContext">
                <result-to-field result-name="returnableQuantity" field-name="returnableQuantity"/>
                <result-to-field result-name="returnablePrice" field-name="returnablePrice"/>
            </call-service>
        </if-not-empty>


        <if-compare field-name="returnableQuantity" value="0" operator="greater" type="Double">
            <!-- the user is only allowed to set a returnPrice if he has ORDERMGR_CREATE privilege, otherwise only the returnablePrice
                 calculated by service is used -->
            <if>
                <condition>
                      <not><if-has-permission permission="ORDERMGR" action="_CREATE"/></not>
                </condition>
                <then>
                      <set from-field="returnablePrice" field="parameters.returnPrice"/>
                </then>
            </if>

            <!-- make sure the returnQuantity is not greater than the returnableQuantity from service or the quantity on the original orderItem -->
            <if-compare-field field-name="returnQuantity" map-name="parameters" operator="greater" to-field-name="returnableQuantity" type="Double">
                <add-error><fail-property resource="OrderErrorUiLabels" property="OrderRequestedReturnQuantityNotAvailablePreviousReturnsMayExist"/></add-error>
            </if-compare-field>

            <!-- SC 20060202: Is this really needed?  Or does the above duplicate it.  If not, we should remove it -->
            <if-not-empty field-name="orderItem">
                <if-compare-field field-name="returnQuantity" map-name="parameters" operator="greater" to-field-name="quantity" to-map-name="orderItem" type="Double">
                    <add-error><fail-property resource="OrderErrorUiLabels" property="OrderReturnQuantityCannotExceedTheOrderedQuantity"/></add-error>
                </if-compare-field>
            </if-not-empty>

            <!-- Workaround for bug: returnPrice=16.99, returnablePrice=16.9894 => OrderReturnPriceCannotExceedThePurchasePrice -->
            <set field="epsilon" value="0.01" type="Double"/>
            <set field="zero" value="0.0" type="Double"/>
            <calculate field-name="returnPriceDelta" type="Double">
                <calcop operator="subtract">
                    <calcop operator="get" field-name="returnPrice" map-name="parameters"/>
                    <calcop operator="get" field-name="returnablePrice"/>
                </calcop>
            </calculate>
			
			<!-- just checking greater-equals sometimes returns an error if the difference is actually zero -->
            <if-compare-field field-name="returnPriceDelta" operator="not-equals" to-field-name="zero" type="Double">
				<if-compare-field field-name="returnPriceDelta" operator="greater-equals" to-field-name="epsilon" type="Double">
					<add-error><fail-property resource="OrderErrorUiLabels" property="OrderReturnPriceCannotExceedThePurchasePrice"/></add-error>
				</if-compare-field >
            </if-compare-field>

            <check-errors/>

            <else>
                <set from-field="parameters.orderId" field="orderId"/>
                <set from-field="parameters.orderItemSeqId" field="orderItemSeqId"/>
                <log level="error" message="Order ${orderId} item ${orderItemSeqId} has been returned in full"/>
                <add-error><fail-property resource="OrderErrorUiLabels" property="OrderIllegalReturnItemTypePassed"/></add-error>
                <check-errors/>
            </else>
        </if-compare>

        <make-value value-name="newEntity" entity-name="ReturnItem"/>
        <!-- do a lookup to find the existing returnItems on this return, order by returnItemSeqId DESC, then get the first one
             and add 1 to returnItemSeqId to get the new returnItemSeqId -->
        <set from-field="parameters.returnId" field="newEntity.returnId"/>
        <set from-field="parameters.returnId" field="lookupMap.returnId"/>
        <string-to-list string="-returnItemSeqId" list-name="orderBy"/>
        <find-by-and entity-name="ReturnItem" list-name="currentItems" map-name="lookupMap" order-by-list-name="orderBy"></find-by-and>
        <if-empty field-name="currentItems">
            <set value="1" field="newEntity.returnItemSeqId"/>
        <else>
           <first-from-list entry-name="newestItem" list-name="currentItems"/>
           <calculate field-name="returnItemSeqId" map-name="newEntity" type="Integer">
               <calcop field-name="returnItemSeqId" map-name="newestItem" operator="add">
                   <number value="1"/>
               </calcop>
           </calculate>
        </else>
        </if-empty>
        <to-string field-name="returnItemSeqId" map-name="newEntity" numeric-padding="5"/>

        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>
        <set field="newEntity.statusId" value="RETURN_REQUESTED"/>  <!-- default status for new return items -->
        <field-to-result field-name="returnItemSeqId" map-name="newEntity" result-name="returnItemSeqId"/>
        <log level="info" message="Return Item Seq ID: ${newEntity.returnItemSeqId}"/>
        <create-value value-name="newEntity"/>
        <refresh-value value-name="newEntity"/>

        <!-- create return adjustments for all adjustments associated with the order item -->
        <if-not-empty field-name="orderItem">
            <get-related value-name="orderItem" relation-name="OrderAdjustment" list-name="orderAdjustments"/>
            <iterate entry-name="orderAdjustment" list-name="orderAdjustments">
                <clear-field field-name="returnAdjCtx"/>
                <set field="returnAdjCtx.returnId" from-field="parameters.returnId"/>
                <set field="returnAdjCtx.returnItemSeqId" from-field="newEntity.returnItemSeqId"/>
                <set field="returnAdjCtx.returnTypeId" from-field="newEntity.returnTypeId"/>
                <set field="returnAdjCtx.orderAdjustmentId" from-field="orderAdjustment.orderAdjustmentId"/>
                <call-service service-name="createReturnAdjustment" in-map-name="returnAdjCtx"/>
            </iterate>
        </if-not-empty>
    </simple-method>
    <simple-method method-name="updateReturnItem" short-description="Update Return Item">
        <check-permission permission="ORDERMGR" action="_UPDATE"><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunUpdateReturnHeader"/></check-permission>
        <check-errors/>

        <set from-field="parameters.returnId" field="lookupPKMap.returnId"/>
        <set from-field="parameters.returnItemSeqId" field="lookupPKMap.returnItemSeqId"/>
        <find-by-primary-key entity-name="ReturnItem" map-name="lookupPKMap" value-name="returnItem"/>
        <set field="originalReturnPrice" from-field="returnItem.returnPrice"/>
        <set field="originalReturnQuantity" from-field="returnItem.returnQuantity"/>
        <field-to-result field-name="returnItem.statusId" result-name="currentStatusId"/>

        <set-nonpk-fields map-name="parameters" value-name="returnItem"/>
        <store-value value-name="returnItem"/>
        <refresh-value value-name="returnItem"/>

        <!-- now update all return adjustments associated with this return item -->
        <entity-and entity-name="ReturnAdjustment" list-name="returnAdjustments">
            <field-map field-name="returnId" env-name="returnItem.returnId"/>
            <field-map field-name="returnItemSeqId" env-name="returnItem.returnItemSeqId"/>
        </entity-and>
        <iterate entry-name="returnAdjustment" list-name="returnAdjustments">
            <log level="info" message="updating returnAdjustment with Id:[${returnAdjustment.returnAdjustmentId}]"/>
            <set-service-fields service-name="updateReturnAdjustment" map-name="returnAdjustment" to-map-name="ctx"/>
            <set field="ctx.originalReturnPrice" from-field="originalReturnPrice"/>
            <set field="ctx.originalReturnQuantity" from-field="originalReturnQuantity"/>
            <set field="ctx.returnTypeId" from-field="returnItem.returnTypeId"/>
            <call-service service-name="updateReturnAdjustment" in-map-name="ctx" include-user-login="true"/>
        </iterate>

    </simple-method>
    <simple-method method-name="updateReturnItemsStatus" short-description="Update Return Items Status">
        <check-permission permission="ORDERMGR" action="_UPDATE"><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunUpdateReturnHeader"/></check-permission>
        <check-errors/>

        <set from-field="parameters.returnId" field="lookupPKMap.returnId"/>
        <find-by-and entity-name="ReturnItem" map-name="lookupPKMap" list-name="returnItems"/>
        <iterate entry-name="item" list-name="returnItems">
            <set field="item.statusId" from-field="parameters.statusId"/>
        </iterate>
        <store-list list-name="returnItems"/>
    </simple-method>
    <simple-method method-name="removeReturnItem" short-description="Remove Return Item">
        <check-permission permission="ORDERMGR" action="_DELETE"><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunRemoveQuoteItem"/></check-permission>
        <check-errors/>

        <set from-field="parameters.returnId" field="headerPKMap.returnId"/>
        <find-by-primary-key entity-name="ReturnHeader" map-name="headerPKMap" value-name="returnHeader"/>
        <if-compare field-name="statusId" map-name="returnHeader" operator="not-equals" type="String" value="RETURN_REQUESTED">
            <add-error><fail-property resource="OrderErrorUiLabels" property="OrderCannotRemoveItemsOnceReturnIsApproved"/></add-error>
            <check-errors/>
        </if-compare>

        <set from-field="parameters.returnId" field="lookupPKMap.returnId"/>
        <set from-field="parameters.returnItemSeqId" field="lookupPKMap.returnItemSeqId"/>
        <find-by-primary-key entity-name="ReturnItem" map-name="lookupPKMap" value-name="returnItem"/>
        <!--remove related  adjustments-->
        <entity-and entity-name="ReturnAdjustment" list-name="returnAdjustments">
            <field-map field-name="returnItemSeqId" env-name="returnItem.returnItemSeqId"/>
            <field-map field-name="returnId" env-name="returnItem.returnId"/>
        </entity-and>
        <iterate entry-name="returnAdjustment" list-name="returnAdjustments">
            <set field="removeCtx.returnAdjustmentId" from-field="returnAdjustment.returnAdjustmentId"/>
            <call-service service-name="removeReturnAdjustment" in-map-name="removeCtx"/>
        </iterate>
        <remove-value value-name="returnItem"/>
    </simple-method>

    <simple-method method-name="createReturnAdjustment" short-description="Create Return Adjustment">
        <if>
            <condition>
                <not><if-has-permission permission="ORDERMGR" action="_CREATE"/></not>
            </condition>
            <then>
                <add-error><fail-message message="Security error to run createReturnAdjustment"/></add-error>
            </then>
        </if>
        <check-errors/>

        <make-value value-name="newEntity" entity-name="ReturnAdjustment"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>
        <sequenced-id-to-env sequence-name="ReturnAdjustment" env-name="newEntity.returnAdjustmentId"/>
        <field-to-result field-name="newEntity.returnAdjustmentId" result-name="returnAdjustmentId"/>
        <create-value value-name="newEntity"/>
        <set field="responseMessage" value="Return Adjustment #${newEntity.returnAdjustmentId} was created successfully."/>
        <field-to-result field-name="responseMessage" result-name="successMessage"/>
    </simple-method>
    <simple-method method-name="removeReturnAdjustment" short-description="Remove Return Adjustment">
        <check-permission permission="ORDERMGR" action="_DELETE"><fail-message message="Order security ErrorToRunUpdateReturnAdjustment"/></check-permission>
        <check-errors/>

        <set from-field="parameters.returnAdjustmentId" field="lookupPKMap.returnAdjustmentId"/>
        <find-by-primary-key entity-name="ReturnAdjustment" map-name="lookupPKMap" value-name="returnAdjustment"/>
        <if-not-empty field-name="returnAdjustment">
            <remove-value value-name="returnAdjustment"/>
        </if-not-empty>
    </simple-method>
    <!-- note that this service is designed to be called once for each shipment receipt that is created -->
    <simple-method method-name="updateReturnStatusFromReceipt" short-description="Update Return Status From ShipmentReceipt">
        <check-permission permission="ORDERMGR" action="_UPDATE"><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunUpdateReturnHeader"/></check-permission>
        <check-errors/>

        <set from-field="parameters.returnId" field="lookupPKMap.returnId"/>
        <find-by-primary-key entity-name="ReturnHeader" map-name="lookupPKMap" value-name="returnHeader"/>
        <find-by-and entity-name="ShipmentReceipt" map-name="lookupPKMap" list-name="shipmentReceipts"/>
        <iterate list-name="shipmentReceipts" entry-name="receipt">
          <if-empty field-name="${receipt.returnItemSeqId}" map-name="totalsMap">
            <calculate field-name="${receipt.returnItemSeqId}" map-name="totalsMap">
              <number value="0"/>
            </calculate>
          </if-empty>
          <calculate field-name="${receipt.returnItemSeqId}" map-name="totalsMap" type="Double">
            <calcop field-name="${receipt.returnItemSeqId}" map-name="totalsMap" operator="add">
              <calcop field-name="quantityAccepted" map-name="receipt" operator="get"/>
              <calcop field-name="quantityRejected" map-name="receipt" operator="get"/>
            </calcop>
          </calculate>
          <set from-field="receipt.returnId" field="newLookupMap.returnId"/>
          <set from-field="receipt.returnItemSeqId" field="newLookupMap.returnItemSeqId"/>
          <find-by-primary-key entity-name="ReturnItem" map-name="newLookupMap" value-name="returnItem"/>
          <if-compare-field field-name="returnQuantity" map-name="returnItem" operator="greater-equals" to-field-name="${receipt.returnItemSeqId}" to-map-name="totalsMap" type="Double">
            <!-- update the status for the item -->
            <set field="returnItem.statusId" value="RETURN_RECEIVED"/>
            <store-value value-name="returnItem"/>
            <!-- create status change history -->
            <make-value entity-name="ReturnStatus" value-name="newValue"/>
            <sequenced-id-to-env sequence-name="ReturnStatus" env-name="returnStatusId"/>
            <set from-field="returnStatusId" field="newValue.returnStatusId"/>

            <set from-field="returnItem.returnItemSeqId" field="newValue.returnId"/>
            <set from-field="returnItem.returnId" field="newValue.returnId"/>
            <set from-field="returnItem.statusId" field="newValuereturnId.returnId"/>

            <now-timestamp-to-env env-name="nowTimestamp"/>
            <set from-field="nowTimestamp" field="newValue.statusDatetime"/>

            <create-value value-name="newValue"/>
          </if-compare-field>
        </iterate>

        <!-- check to see if all items have been received -->
        <set value="true" field="allReceived"/>
        <find-by-and entity-name="ReturnItem" map-name="lookupPKMap" list-name="allReturnItems"/>
        <iterate list-name="allReturnItems" entry-name="item">
          <if-compare field-name="statusId" map-name="item" operator="not-equals" value="RETURN_RECEIVED">
            <if-not-empty field-name="orderItemSeqId" map-name="item">
                <!-- non-order items (i.e. adjustments) are not received -->
                <set value="false" field="allReceived"/>
            </if-not-empty>
          </if-compare>
        </iterate>

        <!-- if the items are all received, then update the return header, store the status history change, and set the shipment to received -->
        <if-compare field-name="allReceived" operator="equals" value="true">

          <!--  Go through all the items yet again and set their shipment status to PURCH_SHIP_RECEIVED (if it isn't already)
          This activates SECAS such as creating return invoices. This MUST be done before updating the return header so that
          the ReturnItemBillings are created and then whatever SECA binds to the return header update will have them. . -->
          <iterate list-name="shipmentReceipts" entry-name="receipt">
            <get-related-one relation-name="Shipment" value-name="receipt" to-value-name="shipment"/>
            <if-not-empty field-name="shipment.shipmentId">
                <if-compare field-name="statusId" map-name="shipment" operator="not-equals" value="RETURN_RECEIVED">
                    <set field="serviceInput.shipmentId" from-field="shipment.shipmentId"/>
                    <set field="serviceInput.statusId" value="PURCH_SHIP_RECEIVED"/>
                    <call-service service-name="updateShipment" in-map-name="serviceInput"/>
                </if-compare>
            </if-not-empty>
          </iterate>

          <!-- update the return header -->
          <set field="returnHeaderCtx.statusId" value="RETURN_RECEIVED"/>
          <set from-field="returnHeader.returnId" field="returnHeaderCtx.returnId"/>
          <call-service service-name="updateReturnHeader" in-map-name="returnHeaderCtx"/>
          <!-- create the status history -->
          <make-value entity-name="ReturnStatus" value-name="newValue"/>
          <sequenced-id-to-env sequence-name="ReturnStatus" env-name="returnStatusId"/>
          <set from-field="returnStatusId" field="newValue.returnStatusId"/>

          <set from-field="returnHeader.returnId" field="newValue.returnId"/>
          <set value="RETURN_RECEIVED" field="newValue.statusId"/>

          <now-timestamp-to-env env-name="nowTimestamp"/>
          <set from-field="nowTimestamp" field="newValue.statusDatetime"/>

          <create-value value-name="newValue"/>
        </if-compare>

        <!-- return the current return header status -->
        <field-to-result field-name="statusId" map-name="returnHeader" result-name="returnHeaderStatus"/>
    </simple-method>
    <simple-method method-name="createReturnItemResponse" short-description="Create a ReturnItemResponse">
        <make-value value-name="newEntity" entity-name="ReturnItemResponse"/>
        <sequenced-id-to-env sequence-name="ReturnItemResponse" env-name="newEntity.returnItemResponseId"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>
        <create-value value-name="newEntity"/>
        <field-to-result field-name="newEntity.returnItemResponseId" result-name="returnItemResponseId"/>
    </simple-method>

    <simple-method method-name="quickReturnFromOrder" short-description="Create Quick Return From Order">
        <if>
          <condition>
            <and>
              <not><if-has-permission permission="ORDERMGR" action="_CREATE"/></not>
              <not><if-compare-field field-name="partyId" map-name="userLogin" operator="equals" to-field-name="fromPartyId" to-map-name="parameters"/></not>
            </and>
          </condition>
          <then>
            <add-error><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunQuickReturnFromOrder"/></add-error>
          </then>
        </if>
        <check-errors/>

        <!-- get primary information from the order header -->
        <entity-one entity-name="OrderHeader" value-name="orderHeader">
            <field-map env-name="parameters.orderId" field-name="orderId"/>
        </entity-one>

        <!-- find the bill to customer; for return's fromPartyId -->
        <entity-condition entity-name="OrderRole" list-name="orderRoles">
            <condition-list combine="and">
                <condition-expr field-name="orderId" operator="equals" env-name="orderHeader.orderId"/>
                <condition-expr field-name="roleTypeId" operator="equals" value="BILL_TO_CUSTOMER"/>
            </condition-list>
        </entity-condition>
        <first-from-list entry-name="orderRole" list-name="orderRoles"/>

        <!-- create the return header -->
        <set from-field="orderHeader.originFacilityId" field="createHeaderCtx.destinationFacilityId"/>
        <set from-field="orderRole.partyId" field="createHeaderCtx.fromPartyId"/>
        <set value="Y" field="updateHeaderCtx.needsInventoryReceive"/>
        <set from-field="parameters.returnHeaderTypeId" field="createHeaderCtx.returnHeaderTypeId"/>

        <!-- get the return to party from the product store -->
        <get-related-one relation-name="ProductStore" value-name="orderHeader" to-value-name="productStore"/>
        <set from-field="productStore.payToPartyId" field="createHeaderCtx.toPartyId"/>

        <if-empty field-name="destinationFacilityId" map-name="createHeaderCtx">
            <get-related-one value-name="orderHeader" relation-name="ProductStore" to-value-name="productStore"/>
            <set from-field="productStore.inventoryFacilityId" field="createHeaderCtx.destinationFacilityId"/>
        </if-empty>

        <!-- copy over the currency of the order to the currency of the return -->
        <set from-field="orderHeader.currencyUom" field="createHeaderCtx.currencyUomId"/>

        <call-service service-name="createReturnHeader" in-map-name="createHeaderCtx" include-user-login="true">
            <result-to-field result-name="returnId"/>
        </call-service>

        <!-- get the available to return order items -->
        <entity-condition entity-name="OrderItem" list-name="orderItems">
            <condition-list combine="and">
                <condition-expr field-name="orderId" operator="equals" env-name="orderHeader.orderId"/>
                <condition-expr field-name="statusId" operator="equals" value="ITEM_COMPLETED"/>
            </condition-list>
        </entity-condition>

        <if-empty field-name="returnReasonId" map-name="parameters">
            <set value="RTN_NOT_WANT" field="parameters.returnReasonId"/>
        </if-empty>
        <if-empty field-name="returnTypeId" map-name="parameters">
            <set value="RTN_REFUND" field="parameters.returnTypeId"/>
        </if-empty>

        <!-- create the return items -->
        <iterate entry-name="orderItem" list-name="orderItems">
            <set from-field="returnId" field="newItemCtx.returnId"/>
            <set from-field="parameters.returnReasonId" field="newItemCtx.returnReasonId"/>
            <set from-field="parameters.returnTypeId" field="newItemCtx.returnTypeId"/>

            <if-not-empty field-name="orderItem.productId">
                <set from-field="orderItem.productId" field="newItemCtx.productId"/>
            </if-not-empty>

            <set from-field="orderItem.orderId" field="newItemCtx.orderId"/>
            <set from-field="orderItem.orderItemSeqId" field="newItemCtx.orderItemSeqId"/>
            <set from-field="orderItem.itemDescription" field="newItemCtx.description"/>

            <!-- get the returnable price and quantity -->
            <set from-field="orderItem" field="itemCheckMap.orderItem"/>
            <call-service service-name="getReturnableQuantity" in-map-name="itemCheckMap">
                <result-to-field result-name="returnableQuantity" field-name="returnQuantity" map-name="newItemCtx"/>
                <result-to-field result-name="returnablePrice" field-name="returnPrice" map-name="newItemCtx"/>
            </call-service>

            <!-- get the matching return item type from the order item type -->

            <set from-field="orderItem.orderItemTypeId" field="orderItemTypeId"/>
            <if-compare field-name="orderItemTypeId" value="PRODUCT_ORDER_ITEM" operator="equals">
            <!-- Check if orderItemTypeId equals PRODUCT_ORDER_ITEM, if so, use ProductType and ReturnItemTypeMap to get ReturnItemType-->
                <entity-one entity-name="Product" value-name="product">
                    <field-map field-name="productId" env-name="orderItem.productId"/>
                    <select-field field-name="productTypeId"/>
                </entity-one>
                <entity-one entity-name="ReturnItemTypeMap" value-name="returnItemTypeMapping">
            	    <field-map env-name="product.productTypeId" field-name="returnItemMapKey"/>
                </entity-one>
            <else>
            <!-- if not, try the ReturnItemTypeMap, but this may not actually work, so log a warning -->
                <log level="warning" message="Trying to find returnItemtype from ReturnItemTypeMap with orderItemtypeId [${orderItem.orderItemTypeId}] for order item [${orderItem}]"/>
                <entity-one entity-name="ReturnItemTypeMap" value-name="returnItemTypeMapping">
                   <field-map env-name="orderItemTypeId" field-name="returnItemMapKey"/>
                </entity-one>
            </else>
            </if-compare>

            <if-empty field-name="returnItemTypeId" map-name="returnItemTypeMapping" >
                <add-error><fail-message message="No matching return item type map found for order item: [${orderItem}]"/></add-error>
                <check-errors/>
            <else>
                <set from-field="returnItemTypeMapping.returnItemTypeId" field="newItemCtx.returnItemTypeId"/>
            </else>
            </if-empty>

            <!-- create the return item -->
            <if-not-empty field-name="newItemCtx.orderAdjustmentId">
                <log level="info" message="Found unexpected orderAdjustment:${newItemCtx.orderAdjustmentId}"/>
                <clear-field field-name="newItemCtx.orderAdjustmentId"/>
            </if-not-empty>
            <if-compare field-name="newItemCtx.returnQuantity" value="0" operator="greater" type="Double">
                <!-- otherwise, items which have been fully returned would still get passed in and then come back with an error -->
                <call-service service-name="createReturnItem" in-map-name="newItemCtx" include-user-login="true"/>
            <else>
                <log level="info" message="This return item is not going to be created because its returnQuantity is zero: ${newItemCtx}"/>
            </else>
            </if-compare>
        </iterate>

        <!-- create a return adjustment for all order adjustments not attached to a particular orderItem (orderItemSeqId = "_NA_") -->
        <entity-condition entity-name="OrderAdjustment" list-name="orderAdjustments">
            <condition-list combine="and">
                <condition-expr field-name="orderId" operator="equals" env-name="orderHeader.orderId"/>
                <condition-expr field-name="orderItemSeqId" operator="equals" value="_NA_"/>
            </condition-list>
        </entity-condition>
        <iterate entry-name="orderAdjustment" list-name="orderAdjustments">
            <clear-field field-name="returnAdjCtx"/>
            <set from-field="orderAdjustment.orderAdjustmentId" field="returnAdjCtx.orderAdjustmentId"/>
            <set from-field="returnId" field="returnAdjCtx.returnId"/>
            <!--filter out orderAdjustment that have been returned-->
            <entity-count entity-name="ReturnAdjustment" count-name="returnCount">
                <condition-expr field-name="orderAdjustmentId" operator="equals" env-name="orderAdjustment.orderAdjustmentId"/>
            </entity-count>
            <if-compare field-name="returnCount" value="0" operator="equals">
                <log level="info" message="Create new return adjustment: ${returnAdjCtx}"/>
                <call-service service-name="createReturnAdjustment" in-map-name="returnAdjCtx" include-user-login="true"/>
            </if-compare>
        </iterate>
        <set field="orderAvailableCtx.orderId" from-field="orderHeader.orderId"/>
        <set field="orderAvailableCtx.countNewReturnItems" value="true" type="Boolean"/> <!-- very important: if this is not set, getOrderAvailableReturnedTotal would not count the return items we just created -->
        <call-service service-name="getOrderAvailableReturnedTotal" in-map-name="orderAvailableCtx">
            <result-to-field result-name="availableReturnTotal" field-name="availableReturnTotal"/>
            <result-to-field result-name="returnTotal" field-name="returnTotal"/>
            <result-to-field result-name="orderTotal" field-name="orderTotal"/>
        </call-service>
        <log level="info" message="OrderTotal [${orderTotal}] - ReturnTotal [${returnTotal}] = available Return Total [${availableReturnTotal}]"/>

        <!-- create a manual balance adjustment based on the difference between order total and return total -->
        <if-compare field-name="availableReturnTotal" operator="not-equals" value="0.00" type="BigDecimal">
            <set value="Balance Adjustment" field="balanceItemCtx.description"/>
            <set value="RET_MAN_ADJ" field="balanceItemCtx.returnAdjustmentTypeId"/>

            <set from-field="returnId" field="balanceItemCtx.returnId"/>
            <set field="balanceItemCtx.returnItemSeqId" value="_NA_"/>
            <set from-field="availableReturnTotal" field="balanceItemCtx.amount" />
            <log level="warning" message="Creating a balance adjustment of [${availableReturnTotal}] for return [${returnId}]"/>

            <!-- create the balance adjustment return item -->
            <call-service service-name="createReturnAdjustment" in-map-name="balanceItemCtx" include-user-login="true"/>
        </if-compare>

        <!-- update the header status -->
        <set value="RETURN_ACCEPTED" field="updateHeaderCtx.statusId"/>
        <set from-field="returnId" field="updateHeaderCtx.returnId"/>
        <call-service service-name="updateReturnHeader" in-map-name="updateHeaderCtx" include-user-login="true"/>

        <!-- auto-receive this return if we passed in the flag -->
        <if-compare field-name="receiveReturn" map-name="parameters" operator="equals" value="true" type="Boolean">
            <set from-field="returnId" field="receiveCtx.returnId"/>
            <call-service service-name="quickReceiveReturn" in-map-name="receiveCtx"/>
        <else>
            <!-- update the header status -->
            <log level="info" message="Receive flag not set; will handle receiving on entity-sync"/>
        </else>
        </if-compare>

        <field-to-result field-name="returnId"/>
    </simple-method>

    <simple-method method-name="createReturnItemBilling" short-description="Create a ReturnItemBilling">
        <make-value entity-name="ReturnItemBilling" value-name="newEntity"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>
        <set-pk-fields map-name="parameters" value-name="newEntity"/>
        <create-value value-name="newEntity"/>
    </simple-method>
	
    <simple-method method-name="cancelReturnItems" short-description="Update a ReturnItems">
        <check-permission permission="ORDERMGR" action="_UPDATE"><fail-property resource="OrderErrorUiLabels" property="OrderSecurityErrorToRunCancelReturnItems"/></check-permission>
        <check-errors/>
        <entity-condition entity-name="ReturnItem" list-name="returnItems" distinct="true">
            <condition-expr field-name="returnId" operator="equals" env-name="parameters.returnId"/>
        </entity-condition>
        <iterate entry-name="returnItem" list-name="returnItems">
            <set field="returnItemMap.returnId" from-field="parameters.returnId"/>
            <set field="returnItemMap.returnItemSeqId" from-field="returnItem.returnItemSeqId"/>
            <set field="returnItemMap.statusId" value="RETURN_CANCELLED" />
            <call-service service-name="updateReturnItem" in-map-name="returnItemMap"/>
        </iterate>
    </simple-method>
</simple-methods>
