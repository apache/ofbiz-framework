<?xml version="1.0" encoding="UTF-8" ?>
<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->

<simple-methods xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
        xsi:noNamespaceSchemaLocation="http://www.ofbiz.org/dtds/simple-methods.xsd">


    <!-- create PartyRole -->
    <simple-method method-name="createPartyRole" short-description="Create Party Role">
        <check-permission permission="PARTYMGR" action="_ROLE_CREATE">
            <accept-userlogin-party/>
            <fail-property resource="PartyUiLabels" property="PartyCreatePartyRolePermissionError"/>
        </check-permission>
        <check-errors/>

        <make-value value-name="partyRolePK" entity-name="PartyRole"/>
        <set-pk-fields value-name="partyRolePK" map-name="parameters"/>
        <find-by-primary-key entity-name="PartyRole" map-name="partyRolePK" value-name="partyRole"/>
        <if-empty field-name="partyRole">
            <make-value entity-name="PartyRole" map-name="partyRolePK" value-name="partyRole"/>
            <create-value value-name="partyRole"/>
        </if-empty>
        <check-errors/>
    </simple-method>

    <simple-method method-name="deletePartyRole" short-description="Delete a  PartyRole">
        <check-permission permission="PARTYMGR" action="_DELETE">
            <accept-userlogin-party/>
            <fail-property resource="PartyUiLabels" property="PartyDeletePartyRolePermissionError"/>
        </check-permission>
        <check-errors/>
        <entity-one entity-name="PartyRole" value-name="partyRole"/>
        <remove-value value-name="partyRole"/>
    </simple-method>
    
    
    <simple-method method-name="savePartyNameChange" short-description="Save Party Name Change">
        <!-- for special case in ecommerce, if no partyId is passed in use userLogin.partyId -->
        <if-empty field-name="parameters.partyId">
            <set field="parameters.partyId" from-field="userLogin.partyId"/>
        </if-empty>
        
        <make-value value-name="partyNameHistory" entity-name="PartyNameHistory"/>
        <set-pk-fields value-name="partyNameHistory" map-name="parameters"/>
        <now-timestamp-to-env env-name="partyNameHistory.changeDate"/>
        
        <if>
            <condition><not><if-empty field-name="parameters.groupName"/></not></condition>
            <then>
                <entity-one entity-name="PartyGroup" value-name="partyGroup"/>
                <if>
                    <condition><if-compare-field field-name="partyGroup.groupName" operator="not-equals" to-field-name="parameters.groupName"/></condition>
                    <then>
                        <set-nonpk-fields value-name="partyNameHistory" map-name="partyGroup"/>
                        <create-value value-name="partyNameHistory"/>
                    </then>
                </if>
            </then>
            <else-if>
                <condition>
                    <or>
                        <not><if-empty field-name="parameters.firstName"></if-empty></not>
                        <not><if-empty field-name="parameters.middleName"></if-empty></not>
                        <not><if-empty field-name="parameters.lastName"></if-empty></not>
                        <not><if-empty field-name="parameters.personalTitle"></if-empty></not>
                        <not><if-empty field-name="parameters.suffix"></if-empty></not>
                    </or>
                </condition>
                <then>
                    <entity-one entity-name="Person" value-name="person"/>
                    <if>
                        <condition>
                            <or>
                                <if-compare-field field-name="person.firstName" operator="not-equals" to-field-name="parameters.firstName"/>
                                <if-compare-field field-name="person.middleName" operator="not-equals" to-field-name="parameters.middleName"/>
                                <if-compare-field field-name="person.lastName" operator="not-equals" to-field-name="parameters.lastName"/>
                                <if-compare-field field-name="person.personalTitle" operator="not-equals" to-field-name="parameters.personalTitle"/>
                                <if-compare-field field-name="person.suffix" operator="not-equals" to-field-name="parameters.suffix"/>
                            </or>
                        </condition>
                        <then>
                            <set-nonpk-fields value-name="partyNameHistory" map-name="person"/>
                            <create-value value-name="partyNameHistory"/>
                        </then>
                    </if>
                </then>
            </else-if>
        </if>        
    </simple-method>
    <simple-method method-name="getPartyNameForDate" short-description="Get Party Name For Date">

        <entity-and entity-name="PartyNameHistory" list-name="partyNameHistoryList">
            <field-map field-name="partyId" env-name="parameters.partyId"/>
            <order-by field-name="-changeDate"/>
        </entity-and>
        <entity-one entity-name="Person" value-name="person"/>
        <entity-one entity-name="PartyGroup" value-name="partyGroup"/>
        <if-empty field-name="parameters.compareDate">
            <now-timestamp-to-env env-name="nowTimestamp"/>
            <set field="parameters.compareDate" from-field="nowTimestamp"/>
        </if-empty>
        <!-- go through the list which is sorted by most recent first and find the oldest (last) one with the changeDate greater than the compareDate -->        
        <iterate entry-name="partyNameHistory" list-name="partyNameHistoryList">
            <if-compare-field field-name="partyNameHistory.changeDate" operator="greater" to-field-name="parameters.compareDate">
                <set field="partyNameHistoryCurrent" from-field="partyNameHistory"/>
            </if-compare-field>
        </iterate>
        
        <if-empty field-name="partyNameHistoryCurrent">
            <if-not-empty field-name="person">
                <field-to-result field-name="person.firstName" result-name="firstName"/>
                <if-not-empty field-name="person.middleName">
                    <field-to-result field-name="person.middleName" result-name="middleName"/>
                </if-not-empty>
                <field-to-result field-name="person.lastName" result-name="lastName"/>
                <if-not-empty field-name="person.personalTitle">
                    <field-to-result field-name="person.personalTitle" result-name="personalTitle"/>
                </if-not-empty>
                <if-not-empty field-name="person.suffix">
                    <field-to-result field-name="person.suffix" result-name="suffix"/>
                </if-not-empty>


                <if-compare field-name="parameters.lastNameFirst" operator="equals" value="Y">
                    <set field="fullName" value="${person.personalTitle} ${person.lastName}, ${person.firstName} ${person.middleName} ${person.suffix}"/>
                <else>
                    <set field="fullName" value="${person.personalTitle} ${person.firstName} ${person.middleName} ${person.lastName} ${person.suffix}"/>
                </else>
                </if-compare>
                <field-to-result field-name="fullName"/>
                
                <else>
                    <if-not-empty field-name="partyGroup">
                        <field-to-result field-name="partyGroup.groupName" result-name="groupName"/>
                        <field-to-result field-name="partyGroup.groupName" result-name="fullName"/>
                    </if-not-empty>
                </else>
            </if-not-empty>
            <else>
                <!-- partyNameHistoryCurrent has a value -->
                <if-not-empty field-name="person">
                    <field-to-result field-name="partyNameHistoryCurrent.firstName" result-name="firstName"/>
                    <if-not-empty field-name="partyNameHistoryCurrent.middleName">
                        <field-to-result field-name="partyNameHistoryCurrent.middleName" result-name="middleName"/>
                    </if-not-empty>
                    <field-to-result field-name="partyNameHistoryCurrent.lastName" result-name="lastName"/>
                    <if-not-empty field-name="partyNameHistoryCurrent.personalTitle">
                        <field-to-result field-name="partyNameHistoryCurrent.personalTitle" result-name="personalTitle"/>
                    </if-not-empty>
                    <if-not-empty field-name="partyNameHistoryCurrent.suffix">
                        <field-to-result field-name="partyNameHistoryCurrent.suffix" result-name="suffix"/>
                    </if-not-empty>

                    
                    <if-compare field-name="parameters.lastNameFirst" operator="equals" value="Y">
                        <set field="fullName" value="${partyNameHistoryCurrent.personalTitle} ${partyNameHistoryCurrent.lastName}, ${partyNameHistoryCurrent.firstName} ${partyNameHistoryCurrent.middleName} ${partyNameHistoryCurrent.suffix}"/>
                    <else>
                        <set field="fullName" value="${partyNameHistoryCurrent.personalTitle} ${partyNameHistoryCurrent.firstName} ${partyNameHistoryCurrent.middleName} ${partyNameHistoryCurrent.lastName} ${partyNameHistoryCurrent.suffix}"/>
                    </else>
                    </if-compare>
                    <field-to-result field-name="fullName"/>
                    
                    <else>
                        <if-not-empty field-name="partyGroup">
                            <field-to-result field-name="partyNameHistoryCurrent.groupName" result-name="groupName"/>
                            <field-to-result field-name="partyNameHistoryCurrent.groupName" result-name="fullName"/>
                        </if-not-empty>
                    </else>
                </if-not-empty>
            </else>
        </if-empty>
    </simple-method>
    
    <!-- PostalAddressBoundary methods -->
    <simple-method method-name="createPostalAddressBoundary" short-description="Create Postal Address Boundary">
        <check-permission permission="PARTYMGR" action="_CREATE"><fail-property resource="PartyUiLabels" property="PartyCreatePostalAddressBoundaryPermissionError"/></check-permission>
        <check-errors/>
        <make-value entity-name="PostalAddressBoundary" value-name="newEntity"/>
        <set-pk-fields map-name="parameters" value-name="newEntity"/>
        <create-value value-name="newEntity"/>
    </simple-method>
    <simple-method method-name="deletePostalAddressBoundary" short-description="Delete a  Postal Address Boundary">
        <check-permission permission="PARTYMGR" action="_DELETE"><fail-property resource="PartyUiLabels" property="PartyRemovePostalAddressBoundaryPermissionError"/></check-permission>
        <check-errors/>
        <entity-one entity-name="PostalAddressBoundary" value-name="postalAddressBoundary"/>
        <remove-value value-name="postalAddressBoundary"/>
    </simple-method>
    <simple-method method-name="getPostalAddressBoundary" short-description="Get Postal Address Boundary">
        <check-permission permission="PARTYMGR" action="_VIEW"><fail-property resource="PartyUiLabels" property="PartyViewPostalAddressBoundaryPermissionError"/></check-permission>
        <check-errors/>
        <make-value entity-name="PostalAddressBoundary" value-name="postalAddressBoundaryLookupMap"/>
        <set field="postalAddressBoundaryLookupMap.geoId" from-field="parameters.geoId"/>
        <find-by-and entity-name="PostalAddressBoundary" map-name="postalAddressBoundaryLookupMap" list-name="postalAddressBoundaries"/>
        
        <iterate list-name="postalAddressBoundaries" entry-name="postalAddressBoundary">
            <get-related-one value-name="postalAddressBoundary" to-value-name="geo" relation-name="Geo"/>
            <field-to-list field-name="geo" list-name="geos"/>
        </iterate>
        <field-to-result field-name="geos"/>
    </simple-method>

    <!-- PartyClassification methods -->
    <simple-method method-name="createPartyClassification" short-description="create a PartyClassification">
        <check-permission permission="PARTYMGR" action="_CREATE"><fail-property resource="PartyUiLabels" property="PartyCreatePartyClassificationPermissionError"/></check-permission>
        <check-errors/>
        <make-value entity-name="PartyClassification" value-name="newEntity"/>
        <set-pk-fields map-name="parameters" value-name="newEntity"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>
        <if-empty field-name="newEntity.fromDate"><now-timestamp-to-env env-name="newEntity.fromDate"/></if-empty>        
        <create-value value-name="newEntity"/>  
    </simple-method>   
    <simple-method method-name="updatePartyClassification" short-description="update a PartyClassification">
        <check-permission permission="PARTYMGR" action="_UPDATE"><fail-property resource="PartyUiLabels" property="PartyUpdatePartyClassificationPermissionError"/></check-permission>
        <check-errors/>
        <entity-one entity-name="PartyClassification" value-name="lookedUpValue"/>
        <set-nonpk-fields value-name="lookedUpValue" map-name="parameters"/>
        <store-value value-name="lookedUpValue"/>
    </simple-method>
    <simple-method method-name="deletePartyClassification" short-description="delete a PartyClassification">
        <check-permission permission="PARTYMGR" action="_DELETE"><fail-property resource="PartyUiLabels" property="PartyRemovePartyClassificationPermissionError"/></check-permission>
        <check-errors/>
        <entity-one entity-name="PartyClassification" value-name="lookedUpValue"/>
        <remove-value value-name="lookedUpValue"/>
    </simple-method>
    <!-- PartyClassificationGroup methods -->
    <simple-method method-name="createPartyClassificationGroup" short-description="create a PartyClassificationGroup">
        <log level="verbose" message="in newEntity" />
        <check-permission permission="PARTYMGR" action="_CREATE"><fail-property resource="PartyUiLabels" property="PartyCreatePartyClassificationGroupPermissionError"/></check-permission>
        <check-errors/>
        <make-value entity-name="PartyClassificationGroup" value-name="newEntity"/>
        <sequenced-id-to-env sequence-name="PartyClassificationGroup" env-name="newEntity.partyClassificationGroupId"/>
        <field-to-result field-name="newEntity.partyClassificationGroupId" result-name="partyClassificationGroupId"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>
        <log level="verbose" message="newEntity:${newEntity}" />
        <create-value value-name="newEntity"/>  
    </simple-method>   
    <simple-method method-name="updatePartyClassificationGroup" short-description="update a PartyClassificationGroup">
        <check-permission permission="PARTYMGR" action="_UPDATE"><fail-property resource="PartyUiLabels" property="PartyUpdatePartyClassificationGroupPermissionError"/></check-permission>
        <check-errors/>
        <entity-one entity-name="PartyClassificationGroup" value-name="lookedUpValue"/>
        <set-nonpk-fields value-name="lookedUpValue" map-name="parameters"/>
        <store-value value-name="lookedUpValue"/>
    </simple-method>
    <simple-method method-name="deletePartyClassificationGroup" short-description="delete a PartyClassificationGroup">
        <check-permission permission="PARTYMGR" action="_DELETE"><fail-property resource="PartyUiLabels" property="PartyRemovePartyClassificationGroupPermissionError"/></check-permission>
        <check-errors/>
        <entity-one entity-name="PartyClassificationGroup" value-name="lookedUpValue"/>
        <remove-value value-name="lookedUpValue"/>
    </simple-method>
    
    <!-- Vendor Party services -->
    <simple-method method-name="createVendor" short-description="createVendor">
        <check-permission permission="PARTYMGR" action="_CREATE">
            <fail-property resource="PartyUiLabels" property="PartyCreateVendorPermissionError"/>
        </check-permission>
        <check-errors/>

        <make-value value-name="newEntity" entity-name="Vendor"/>
        <set-pk-fields map-name="parameters" value-name="newEntity"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>
        
        <create-value value-name="newEntity"/>
    </simple-method>
    <simple-method method-name="updateVendor" short-description="updateVendor">
        <check-permission permission="PARTYMGR" action="_UPDATE">
            <fail-property resource="PartyUiLabels" property="PartyUpdateVendorPermissionError"/>
        </check-permission>
        <check-errors/>

        <entity-one entity-name="Vendor" value-name="lookedUpValue"/>
        <set-nonpk-fields map-name="parameters" value-name="lookedUpValue"/>
        <store-value value-name="lookedUpValue"/>
    </simple-method>
    <simple-method method-name="deleteVendor" short-description="deleteVendor">
        <check-permission permission="PARTYMGR" action="_DELETE">
            <fail-property resource="PartyUiLabels" property="PartyDeleteVendorPermissionError"/>
        </check-permission>
        <check-errors/>

        <entity-one entity-name="Vendor" value-name="lookedUpValue"/>
        <remove-value value-name="lookedUpValue"/>
    </simple-method>

    <!-- party attribute services -->
    <simple-method method-name="createPartyAttribute" short-description="cratePartyAttribute">
        <check-permission permission="PARTYMGR" action="_CREATE">
            <fail-property resource="PartyUiLabels" property="PartyCreateAttributePermissionError"/>
        </check-permission>
        <check-errors/>

        <make-value value-name="newEntity" entity-name="PartyAttribute"/>
        <set-pk-fields map-name="parameters" value-name="newEntity"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>

        <create-value value-name="newEntity"/>
    </simple-method>
    <simple-method method-name="updatePartyAttribute" short-description="updatePartyAttribute">
        <check-permission permission="PARTYMGR" action="_UPDATE">
            <fail-property resource="PartyUiLabels" property="PartyUpdateAttributePermissionError"/>
        </check-permission>
        <check-errors/>

        <entity-one entity-name="PartyAttribute" value-name="lookedUpValue"/>
        <set-nonpk-fields map-name="parameters" value-name="lookedUpValue"/>
        <store-value value-name="lookedUpValue"/>
    </simple-method>
    <simple-method method-name="removePartyAttribute" short-description="removePartyAttribute">
        <check-permission permission="PARTYMGR" action="_DELETE">
            <fail-property resource="PartyUiLabels" property="PartyRemoveAttributePermissionError"/>
        </check-permission>
        <check-errors/>

        <entity-one entity-name="PartyAttribute" value-name="lookedUpValue"/>
        <remove-value value-name="lookedUpValue"/>
    </simple-method>

    <!-- party profile default -->
    <simple-method method-name="setPartyProfileDefaults" short-description="Sets Party Profile Defaults">
        <!-- check make sure we have permission to set this -->
        <if-empty map-name="parameters" field-name="partyId">
            <set from-field="userLogin.partyId" field="parameters.partyId"/>
        </if-empty>
        <if-compare-field field-name="partyId" map-name="parameters" to-map-name="userLogin" operator="not-equals">
            <check-permission permission="PARTYMGR" action="_UPDATE">
                <fail-property resource="PartyUiLabels" property="PartyPermissionErrorForThisParty"/>
            </check-permission>
        </if-compare-field>

        <!-- lookup existing value -->
        <entity-one entity-name="PartyProfileDefault" value-name="partyProfileDefault"/>
        <if-empty field-name="partyProfileDefault">
            <make-value value-name="partyProfileDefault" entity-name="PartyProfileDefault"/>
            <set-pk-fields value-name="partyProfileDefault" map-name="parameters"/>
            <create-value value-name="partyProfileDefault"/>
        </if-empty>

        <!-- update the fields -->
        <set-nonpk-fields value-name="partyProfileDefault" map-name="parameters" set-if-null="false"/>
        <store-value value-name="partyProfileDefault"/>
    </simple-method>
    
    <!-- create party content -->
    <!-- TODO: this method will be deleted in favor of new content methods and the PartyContentServices.xml -->
    <simple-method method-name="createPartyContent" short-description="Creates Party Associated Content" login-required="false">
           <!-- make sure we are logged in when passing a partyId -->
        <if-not-empty field-name="partyId" map-name="parameters">
            <if-empty field-name="userLogin" map-name="parameters">
                <add-error><fail-property resource="PartyUiLabels" property="PartyPermissionErrorForThisParty"/></add-error>
                <check-errors/>
            </if-empty>
        </if-not-empty>

        <!-- check permission when creating content on behalf of another party -->
        <if-empty field-name="partyId" map-name="parameters">
            <if-not-empty field-name="userLogin" map-name="parameters">
                <set from-field="userLogin.partyId" field="parameters.partyId"/>
                <if-compare-field field-name="partyId" map-name="parameters" to-map-name="userLogin" operator="not-equals">
                    <check-permission permission="PARTYMGR" action="_UPDATE">
                        <fail-property resource="PartyUiLabels" property="PartyPermissionErrorForThisParty"/>
                    </check-permission>
                </if-compare-field>
            </if-not-empty>
        </if-empty>
       <if-not-empty field-name="_uploadedFile_fileName" map-name="parameters">                    
           <call-class-method class-name="org.ofbiz.content.data.DataResourceWorker" method-name="getDataResourceContentUploadPath" ret-field-name="uploadPath"/>
           <log level="always" message="[createPartyContent] - Found Subdir : ${uploadPath}"/>
           <!-- locate the file extension to use based on mime-type -->
           <set from-field="parameters._uploadedFile_contentType" field="extenLookup.mimeTypeId"/>
           <find-by-and entity-name="FileExtension" map-name="extenLookup" list-name="extensions"/>
           <first-from-list entry-name="extension" list-name="extensions"/>
           <set-service-fields service-name="createDataResource" map-name="parameters" to-map-name="dataResource"/>
           <!-- create the data resource object -->
           <set from-field="parameters._uploadedFile_fileName" field="dataResource.dataResourceName"/>
           <set from-field="parameters._uploadedFile_contentType" field="dataResource.mimeTypeId"/>
           <set value="${uploadPath}/${dataResource.dataResourceId}" field="dataResource.objectInfo"/>
           <if-not-empty field-name="extension">
              <set value="${uploadPath}/${dataResource.dataResourceId}.${extension.fileExtensionId}" field="dataResource.objectInfo"/>
           </if-not-empty>
           <set value="LOCAL_FILE" field="dataResource.dataResourceTypeId"/>
           <call-service service-name="createDataResource" in-map-name="dataResource" break-on-error="false">
               <result-to-field result-name="dataResourceId" field-name="dataResourceId"/>
               <result-to-field result-name="dataResource" field-name="dataResourceMap"/>
           </call-service>           
       </if-not-empty>
        
       <set-service-fields service-name="createContent" map-name="parameters" to-map-name="createContentMap"/>
       <if-not-empty field-name="_uploadedFile_fileName" map-name="parameters">
            <set from-field="dataResourceId" field="createContentMap.dataResourceId"/>
       </if-not-empty>
       <call-service service-name="createContent" in-map-name="createContentMap" break-on-error="false">
            <result-to-field result-name="contentId" field-name="contentId"/>
       </call-service>        
       <!-- create the content role -->
       <if-not-empty field-name="partyId" map-name="parameters">
            <now-timestamp-to-env env-name="nowTimestamp"/>
            <set-service-fields service-name="createContentRole" map-name="parameters" to-map-name="contentRole"/>
            <set from-field="contentId" field="contentRole.contentId"/>
            <set from-field="parameters.partyId" field="contentRole.partyId"/>
            <set from-field="nowTimestamp" field="contentRole.fromDate"/>
            <set value="OWNER" field="contentRole.roleTypeId"/>
            <call-service service-name="createContentRole" in-map-name="contentRole" break-on-error="false" />
            <!-- check party role -->
            <make-value value-name="partyRole" entity-name="PartyRole"/>
            <set-pk-fields value-name="partyRole" map-name="contentRole"/>
            <find-by-and entity-name="PartyRole" map-name="partyRole" list-name="pRoles"/>
            <if-empty field-name="pRoles">
                <set-service-fields service-name="createPartyRole" map-name="contentRole" to-map-name="partyRole"/>
                <call-service service-name="createPartyRole" in-map-name="partyRole" break-on-error="false" />    
            </if-empty>
       </if-not-empty>       
       <if-not-empty field-name="_uploadedFile_fileName" map-name="parameters">
            <!-- store the file -->
            <set-service-fields service-name="createAnonFile" map-name="dataResourceMap" to-map-name="fileCtx"/>
            <set from-field="parameters.uploadedFile" field="fileCtx.binData"/>
            <set from-field="dataResourceMap" field="fileCtx.dataResource"/>
            <call-service service-name="createAnonFile" in-map-name="fileCtx" include-user-login="true"/>
        </if-not-empty>
       <field-to-result field-name="contentId" />                
    </simple-method>

    <!-- Update party content -->
    <!-- TODO: this method will be deleted in favor of new content methods and the PartyContentServices.xml -->
    <simple-method method-name="updatePartyContent" short-description="Creates Party Associated Content" login-required="false">
           <!-- make sure we are logged in when passing a partyId -->
        <if-not-empty field-name="partyId" map-name="parameters">
            <if-empty field-name="userLogin" map-name="parameters">
                <add-error><fail-property resource="PartyUiLabels" property="PartyPermissionErrorForThisParty"/></add-error>
                <check-errors/>
            </if-empty>
        </if-not-empty>

        <!-- check permission when creating content on behalf of another party -->
        <if-empty field-name="partyId" map-name="parameters">
            <if-not-empty field-name="userLogin" map-name="parameters">
                <set from-field="userLogin.partyId" field="parameters.partyId"/>
                <if-compare-field field-name="partyId" map-name="parameters" to-map-name="userLogin" operator="not-equals">
                    <check-permission permission="PARTYMGR" action="_UPDATE">
                        <fail-property resource="PartyUiLabels" property="PartyPermissionErrorForThisParty"/>
                    </check-permission>
                </if-compare-field>
            </if-not-empty>
        </if-empty>
                
        <if-not-empty field-name="_uploadedFile_fileName" map-name="parameters">                    
           <set from-field="parameters.contentId" field="lookupParam.contentId"/>
           <find-by-primary-key use-cache="true" entity-name="Content" value-name="content" map-name="lookupParam"/>
           <if-not-empty field-name="dataResourceId" map-name="content">
               <set-service-fields service-name="updateDataResource" map-name="parameters" to-map-name="dataResource"/>           
               <set from-field="content.dataResourceId" field="dataResource.dataResourceId"/>
               <call-service service-name="updateDataResource" in-map-name="dataResource" break-on-error="false" />
               <set from-field="content.dataResourceId" field="lookup.dataResourceId"/>
               <find-by-primary-key use-cache="true" entity-name="DataResource" value-name="dataResourceMap" map-name="lookup"/>
            <else>
               <call-class-method class-name="org.ofbiz.content.data.DataResourceWorker" method-name="getDataResourceContentUploadPath" ret-field-name="uploadPath"/>
               <log level="always" message="[createPartyContent] - Found Subdir : ${uploadPath}"/>
               <!-- locate the file extension to use based on mime-type -->
               <set from-field="parameters._uploadedFile_contentType" field="extenLookup.mimeTypeId"/>
               <find-by-and entity-name="FileExtension" map-name="extenLookup" list-name="extensions"/>
               <first-from-list entry-name="extension" list-name="extensions"/>
               <set-service-fields service-name="createDataResource" map-name="parameters" to-map-name="dataResource"/>
               <!-- create the data resource object -->
               <set from-field="parameters._uploadedFile_fileName" field="dataResource.dataResourceName"/>
               <set from-field="parameters._uploadedFile_contentType" field="dataResource.mimeTypeId"/>
               <set value="${uploadPath}/${dataResource.dataResourceId}" field="dataResource.objectInfo"/>
               <if-not-empty field-name="extension">
                   <set value="${uploadPath}/${dataResource.dataResourceId}.${extension.fileExtensionId}" field="dataResource.objectInfo"/>
               </if-not-empty>
               <set value="LOCAL_FILE" field="dataResource.dataResourceTypeId"/>
               <call-service service-name="createDataResource" in-map-name="dataResource" break-on-error="false">
                   <result-to-field result-name="dataResourceId" field-name="dataResourceId"/>
                   <result-to-field result-name="dataResource" field-name="dataResourceMap"/>
               </call-service>              
            </else>   
           </if-not-empty>           
       </if-not-empty>        
       <set-service-fields service-name="updateContent" map-name="parameters" to-map-name="updateContentMap"/>
       <if-not-empty field-name="dataResourceId">
           <set from-field="dataResourceId" field="updateContentMap.dataResourceId" />
       </if-not-empty>
       <call-service service-name="updateContent" in-map-name="updateContentMap" break-on-error="false" />
       <if-not-empty field-name="_uploadedFile_fileName" map-name="parameters">
          <set-service-fields service-name="createAnonFile" map-name="dataResourceMap" to-map-name="fileCtx"/>
          <set from-field="parameters.uploadedFile" field="fileCtx.binData"/>
          <set from-field="dataResourceMap" field="fileCtx.dataResource"/>
          <call-service service-name="createAnonFile" in-map-name="fileCtx" include-user-login="true"/>
      </if-not-empty> 
      <field-to-result map-name="parameters" field-name="contentId" result-name="contentId" />  
    </simple-method>       
    
    <!-- get parties based on PartyRelationship -->
    <simple-method method-name="getPartiesByRelationship" 
            short-description="Gets all parties related to partyIdFrom using the PartyRelationship entity" login-required="false">
        <set from-field="parameters.partyIdFrom" field="lookupMap.partyIdFrom"/>
        <set from-field="parameters.partyIdTo" field="lookupMap.partyIdTo"/>
        <set from-field="parameters.roleTypeIdFrom" field="lookupMap.roleTypeIdFrom"/>
        <set from-field="parameters.roleTypeIdTo" field="lookupMap.roleTypeIdTo"/>
        <set from-field="parameters.statusId" field="lookupMap.statusId"/>
        <set from-field="parameters.priorityTypeId" field="lookupMap.priorityTypeId"/>
        <set from-field="parameters.partyRelationshipTypeId" field="lookupMap.partyRelationshipTypeId"/>
        
        <find-by-and entity-name="PartyRelationship" map-name="lookupMap" list-name="partyRelationships"/>
        <iterate list-name="partyRelationships" entry-name="partyRelationship">
            <get-related-one value-name="partyRelationship" relation-name="ToParty" to-value-name="party"/>
            <field-to-list field-name="party" list-name="parties"/>
        </iterate>
        <if-not-empty field-name="parties">   
            <field-to-result field-name="parties"/>
        </if-not-empty>         
    </simple-method>    

    <simple-method method-name="getParentOrganizations" short-description="Gets Parent Organizations for an Organization Party">
        <set from-field="parameters.organizationPartyId" field="relatedPartyIdList[]"/>
        <set from-field="parameters.getParentsOfParents" field="recurse"/>
        <if-empty field-name="recurse"><set value="Y" field="recurse"/></if-empty>
        
        <set value="GROUP_ROLLUP" field="partyRelationshipTypeId"/>
        <set value="ORGANIZATION_UNIT" field="roleTypeIdFrom"/>
        <set value="PARENT_ORGANIZATION" field="roleTypeIdTo"/>
        <set value="Y" field="roleTypeIdFromInclueAllChildTypes"/>

        <set value="Y" field="includeFromToSwitched"/>
        
        <call-simple-method method-name="followPartyRelationshipsInline"/>
        
        <field-to-result field-name="relatedPartyIdList" result-name="parentOrganizationPartyIdList"/>
    </simple-method>    

    <simple-method method-name="getRelatedParties" short-description="Get Parties Related to a Party">
        <set from-field="parameters.partyIdFrom" field="relatedPartyIdList[]"/>
        <set from-field="parameters.partyRelationshipTypeId" field="partyRelationshipTypeId"/>
        <set from-field="parameters.roleTypeIdFrom" field="roleTypeIdFrom"/>
        <set from-field="parameters.roleTypeIdFromInclueAllChildTypes" field="roleTypeIdFromInclueAllChildTypes"/>
        <set from-field="parameters.roleTypeIdTo" field="roleTypeIdTo"/>
        <set from-field="parameters.roleTypeIdToIncludeAllChildTypes" field="roleTypeIdToIncludeAllChildTypes"/>
        <set from-field="parameters.includeFromToSwitched" field="includeFromToSwitched"/>
        <set from-field="parameters.recurse" field="recurse"/>
        <set from-field="parameters.useCache" field="useCache"/>
        
        <call-simple-method method-name="followPartyRelationshipsInline"/>

        <field-to-result field-name="relatedPartyIdList"/>
    </simple-method>
    
    <simple-method method-name="followPartyRelationshipsInline" short-description="followPartyRelationshipsInline">
        <!--
            Uses the following fields in the env (with * are required):
             - relatedPartyIdList* (initial partyIdFrom should be in this list; accumulator of new partyIds, ie all partyIdTo found will be added to this, thus can support recursion)
             - partyRelationshipTypeId
             - roleTypeIdFrom
             - roleTypeIdFromInclueAllChildTypes
             - roleTypeIdTo
             - roleTypeIdToIncludeAllChildTypes
             - includeFromToSwitched
             - recurse
             - useCache (should be "true" or "false")
        -->
        
        <if-empty field-name="nowTimestamp"><now-timestamp-to-env env-name="nowTimestamp"/></if-empty>
        
        <!-- only create these if they don't already exist, more efficient and avoids potential problems in recursed calls -->
        <if-empty field-name="_inline_roleTypeIdFromList">
            <field-to-list field-name="roleTypeIdFrom" list-name="_inline_roleTypeIdFromList"/>
            <if-compare field-name="roleTypeIdFromInclueAllChildTypes" operator="equals" value="Y">
                <set value="_inline_roleTypeIdFromList" field="roleTypeIdListName"/>
                <call-simple-method method-name="getChildRoleTypesInline"/>
            </if-compare>
        </if-empty>
        <if-empty field-name="_inline_roleTypeIdToList">
            <field-to-list field-name="roleTypeIdTo" list-name="_inline_roleTypeIdToList"/>
            <if-compare field-name="roleTypeIdToInclueAllChildTypes" operator="equals" value="Y">
                <set value="_inline_roleTypeIdToList" field="roleTypeIdListName"/>
                <call-simple-method method-name="getChildRoleTypesInline"/>
            </if-compare>
        </if-empty>

        <call-simple-method method-name="followPartyRelationshipsInlineRecurse"/>
    </simple-method>
    <simple-method method-name="followPartyRelationshipsInlineRecurse" short-description="followPartyRelationshipsInlineRecurse">
        <clear-field field-name="_inline_NewRelatedPartyIdList"/>
        
        <iterate entry-name="relatedPartyId" list-name="relatedPartyIdList">
            <if>
                <condition><not><if-compare-field field-name="_inline_relatedPartyIdAlreadySearchedList" operator="contains" to-field-name="relatedPartyId"/></not></condition>
                <then>
                    <field-to-list field-name="relatedPartyId" list-name="_inline_relatedPartyIdAlreadySearchedList"/>
                    
                    <clear-field field-name="_inline_PartyRelationshipList"/>
                    <entity-condition entity-name="PartyRelationship" list-name="_inline_PartyRelationshipList" use-cache="${useCache}">
                        <condition-list combine="and">
                            <condition-expr field-name="partyIdFrom" env-name="relatedPartyId"/>
                            <condition-expr field-name="roleTypeIdFrom" operator="in" env-name="_inline_roleTypeIdFromList" ignore-if-empty="true"/>
                            <condition-expr field-name="roleTypeIdTo" operator="in" env-name="_inline_roleTypeIdToList" ignore-if-empty="true"/>
                            <condition-expr field-name="partyRelationshipTypeId" env-name="partyRelationshipTypeId" ignore-if-empty="true"/>
            
                            <condition-expr field-name="fromDate" operator="less-equals" env-name="nowTimestamp"/>
                            <condition-list combine="or">
                                <condition-expr field-name="thruDate" operator="equals" env-name="nullField"/>
                                <condition-expr field-name="thruDate" operator="greater" env-name="nowTimestamp"/>
                            </condition-list>
                        </condition-list>
                        
                        <!-- get the newest (highest date) first -->
                        <order-by field-name="-fromDate"/>
                    </entity-condition>
                    <iterate entry-name="_inline_PartyRelationship" list-name="_inline_PartyRelationshipList">
                        <if>
                            <condition>
                                <and>
                                    <not><if-compare-field field-name="relatedPartyIdList" operator="contains" to-field-name="_inline_PartyRelationship.partyIdTo"/></not>
                                    <not><if-compare-field field-name="_inline_NewRelatedPartyIdList" operator="contains" to-field-name="_inline_PartyRelationship.partyIdTo"/></not>
                                </and>
                            </condition>
                            <then>
                                <field-to-list field-name="_inline_PartyRelationship.partyIdTo" list-name="_inline_NewRelatedPartyIdList"/>
                            </then>
                        </if>
                    </iterate>
                    
                    <if-compare field-name="includeFromToSwitched" operator="equals" value="Y">
                        <clear-field field-name="_inline_PartyRelationshipList"/>
                        <entity-condition entity-name="PartyRelationship" list-name="_inline_PartyRelationshipList" use-cache="${useCache}">
                            <condition-list combine="and">
                                <condition-expr field-name="partyIdTo" env-name="relatedPartyId"/>
                                <condition-expr field-name="roleTypeIdTo" operator="in" env-name="_inline_roleTypeIdFromList" ignore-if-empty="true"/>
                                <condition-expr field-name="roleTypeIdFrom" operator="in" env-name="_inline_roleTypeIdToList" ignore-if-empty="true"/>
                                <condition-expr field-name="partyRelationshipTypeId" env-name="partyRelationshipTypeId" ignore-if-empty="true"/>
                
                                <condition-expr field-name="fromDate" operator="less-equals" env-name="nowTimestamp"/>
                                <condition-list combine="or">
                                    <condition-expr field-name="thruDate" operator="equals" env-name="nullField"/>
                                    <condition-expr field-name="thruDate" operator="greater" env-name="nowTimestamp"/>
                                </condition-list>
                            </condition-list>
                            
                            <!-- get the newest (highest date) first -->
                            <order-by field-name="-fromDate"/>
                        </entity-condition>
                        <iterate entry-name="_inline_PartyRelationship" list-name="_inline_PartyRelationshipList">
                            <if>
                                <condition>
                                    <and>
                                        <not><if-compare-field field-name="relatedPartyIdList" operator="contains" to-field-name="_inline_PartyRelationship.partyIdFrom"/></not>
                                        <not><if-compare-field field-name="_inline_NewRelatedPartyIdList" operator="contains" to-field-name="_inline_PartyRelationship.partyIdFrom"/></not>
                                    </and>
                                </condition>
                                <then>
                                    <field-to-list field-name="_inline_PartyRelationship.partyIdFrom" list-name="_inline_NewRelatedPartyIdList"/>
                                </then>
                            </if>
                        </iterate>
                    </if-compare>
                </then>
            </if>
        </iterate>
        
        <!-- if we found new ones, add them to the master list and if recurse=Y then recurse -->
        <if-not-empty field-name="_inline_NewRelatedPartyIdList">
            <list-to-list list-name="_inline_NewRelatedPartyIdList" to-list-name="relatedPartyIdList"/>
            <if-compare field-name="recurse" operator="equals" value="Y">
                <log level="verbose" message="Recursively calling followPartyRelationshipsInlineRecurse _inline_NewRelatedPartyIdList=${_inline_NewRelatedPartyIdList}"/>
                <call-simple-method method-name="followPartyRelationshipsInlineRecurse"/>
            </if-compare>
        </if-not-empty>
    </simple-method>
    
    <simple-method method-name="getChildRoleTypes" short-description="Get Child RoleTypes">
        <field-to-list field-name="roleTypeId" list-name="childRoleTypeIdList"/>
        <set value="childRoleTypeIdList" field="roleTypeIdListName"/>
        <call-simple-method method-name="getChildRoleTypesInline"/>
        <field-to-result field-name="childRoleTypeIdList"/>
    </simple-method>
    <simple-method method-name="getChildRoleTypesInline" short-description="getChildRoleTypes">
        <clear-field field-name="_inline_NewRoleTypeIdList"/>
        
        <iterate entry-name="roleTypeId" list-name="${roleTypeIdListName}">
            <if>
                <condition><not><if-compare-field field-name="_inline_roleTypeIdAlreadySearchedList" operator="contains" to-field-name="roleTypeId"/></not></condition>
                <then>
                    <field-to-list field-name="roleTypeId" list-name="_inline_roleTypeIdAlreadySearchedList"/>
                    
                    <clear-field field-name="_inline_RoleTypeList"/>
                    <entity-condition entity-name="RoleType" list-name="_inline_RoleTypeList" use-cache="true">
                        <condition-expr field-name="parentTypeId" operator="equals" env-name="roleTypeId"/>
                    </entity-condition>
                    <iterate entry-name="newRoleType" list-name="_inline_RoleTypeList">
                        <if>
                            <condition>
                                <and>
                                    <not><if-compare-field field-name="${roleTypeIdListName}" operator="contains" to-field-name="newRoleType.roleTypeId"/></not>
                                    <not><if-compare-field field-name="_inline_NewRoleTypeIdList" operator="contains" to-field-name="newRoleType.roleTypeId"/></not>
                                </and>
                            </condition>
                            <then>
                                <field-to-list field-name="newRoleType.roleTypeId" list-name="_inline_NewRoleTypeIdList"/>
                            </then>
                        </if>
                    </iterate>
                </then>
            </if>
        </iterate>
        
        <!-- if we found some new types, add them to the main list -->
        <if-not-empty field-name="_inline_NewRoleTypeIdList">
            <list-to-list list-name="_inline_NewRoleTypeIdList" to-list-name="${roleTypeIdListName}"/>
            <log level="verbose" message="Recursively calling getChildRoleTypesInline roleTypeIdListName=${roleTypeIdListName}, _inline_NewRoleTypeIdList=${_inline_NewRoleTypeIdList}"/>
            <call-simple-method method-name="getChildRoleTypesInline"/>
        </if-not-empty>
    </simple-method>    

    <simple-method method-name="getPartyEmail" short-description="Get the email of the party">
        <set field="findMap.partyId" from-field="parameters.partyId"/>
        <set field="findMap.contactMechTypeId" value="EMAIL_ADDRESS"/>
        <find-by-and entity-name="PartyAndContactMech" map-name="findMap" list-name="emailAddressesAll"/>
        <if-empty field-name="emailAddressesAll">
            <set field="findMap.contactMechTypeId" value="ELECTRONIC_ADDRESS"/>
            <find-by-and entity-name="PartyAndContactMech" map-name="findMap" list-name="emailAddressesAll"/>
        </if-empty>
        <now-date-to-env env-name="fromDate"/>
        <filter-list-by-date list-name="emailAddressesAll" from-field-name="fromDate" to-list-name="emailAddresses"/>
        <first-from-list entry-name="emailAddress" list-name="emailAddresses"/>
        <field-to-result field-name="emailAddress.infoString" result-name="emailAddress"/>
    </simple-method>

    <!-- address match map -->
    <simple-method method-name="createAddressMatchMap" short-description="create a AddressMatchMap">
        <call-object-method obj-field-name="mapValue" obj-map-name="parameters" method-name="toUpperCase" ret-field-name="mapValue" ret-map-name="parameters"/>
        <call-object-method obj-field-name="mapKey" obj-map-name="parameters" method-name="toUpperCase" ret-field-name="mapKey" ret-map-name="parameters"/>
        <make-value entity-name="AddressMatchMap" value-name="newEntity"/>
        <set-pk-fields map-name="parameters" value-name="newEntity"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>
        <create-value value-name="newEntity"/>
    </simple-method>
    <simple-method method-name="deleteAddressMatchMap" short-description="remove a AddressMatchMap">
        <make-value entity-name="AddressMatchMap" value-name="fieldMap"/>
        <set-pk-fields map-name="parameters" value-name="fieldMap"/>
        <remove-value value-name="fieldMap"/>
    </simple-method>
    <simple-method method-name="clearAddressMatchMap" short-description="remove all AddressMatchMap">
        <entity-condition entity-name="AddressMatchMap" list-name="addrs">
            <use-iterator/>
        </entity-condition>
        <iterate entry-name="addr" list-name="addrs">
            <remove-value value-name="addr"/>
        </iterate>        
    </simple-method>

    <!-- PartyRelationship services -->
    <simple-method method-name="createPartyRelationship" short-description="createPartyRelationship">
        <if-empty field-name="parameters.partyIdFrom">
            <set field="parameters.partyIdFrom" from-field="userLogin.partyId"/>
            <else>
                <check-permission permission="PARTYMGR_REL" action="_CREATE">
                    <alt-permission permission="PARTYMGR" action="_CREATE"/>
                    <fail-property resource="ServiceErrorUiLabels" property="serviceUtil.no_permission_to_operation"/>
                </check-permission>
            </else>
        </if-empty>
        <check-errors/>
        
        <if-empty field-name="parameters.roleTypeIdFrom"><set field="parameters.roleTypeIdFrom" value="_NA_"/></if-empty>
        <if-empty field-name="parameters.roleTypeIdTo"><set field="parameters.roleTypeIdTo" value="_NA_"/></if-empty>

        <if-empty field-name="parameters.fromDate"><now-timestamp-to-env env-name="parameters.fromDate"/></if-empty>
        
        <make-value value-name="newEntity" entity-name="PartyRelationship"/>
        <set-pk-fields map-name="parameters" value-name="newEntity"/>
        <set-nonpk-fields map-name="parameters" value-name="newEntity"/>
        
        <create-value value-name="newEntity"/>
    </simple-method>
    <simple-method method-name="updatePartyRelationship" short-description="updatePartyRelationship">
        <if-empty field-name="parameters.partyIdFrom">
            <set field="parameters.partyIdFrom" from-field="userLogin.partyId"/>
            <else>
                <check-permission permission="PARTYMGR_REL" action="_UPDATE">
                    <alt-permission permission="PARTYMGR" action="_UPDATE"/>
                    <fail-property resource="ServiceErrorUiLabels" property="serviceUtil.no_permission_to_operation"/>
                </check-permission>
            </else>
        </if-empty>
        <check-errors/>
        
        <if-empty field-name="parameters.roleTypeIdFrom"><set field="parameters.roleTypeIdFrom" value="_NA_"/></if-empty>
        <if-empty field-name="parameters.roleTypeIdTo"><set field="parameters.roleTypeIdTo" value="_NA_"/></if-empty>
        
        <entity-one entity-name="PartyRelationship" value-name="lookedUpValue"/>
        <set-nonpk-fields map-name="parameters" value-name="lookedUpValue"/>
        <store-value value-name="lookedUpValue"/>
    </simple-method>
    <simple-method method-name="deletePartyRelationship" short-description="deletePartyRelationship">
        <if-empty field-name="parameters.partyIdFrom">
            <set field="parameters.partyIdFrom" from-field="userLogin.partyId"/>
            <else>
                <check-permission permission="PARTYMGR_REL" action="_DELETE">
                    <alt-permission permission="PARTYMGR" action="_DELETE"/>
                    <fail-property resource="ServiceErrorUiLabels" property="serviceUtil.no_permission_to_operation"/>
                </check-permission>
            </else>
        </if-empty>
        <check-errors/>
        
        <if-empty field-name="parameters.roleTypeIdFrom"><set field="parameters.roleTypeIdFrom" value="_NA_"/></if-empty>
        <if-empty field-name="parameters.roleTypeIdTo"><set field="parameters.roleTypeIdTo" value="_NA_"/></if-empty>

        <entity-one entity-name="PartyRelationship" value-name="lookedUpValue"/>
        <remove-value value-name="lookedUpValue"/>
    </simple-method>
</simple-methods>
