<?xml version="1.0" encoding="UTF-8" ?>
<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->

<simple-methods xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://ofbiz.apache.org/Simple-Method" xsi:schemaLocation="http://ofbiz.apache.org/Simple-Method http://ofbiz.apache.org/dtds/simple-methods.xsd">

    <simple-method method-name="savePartyNameChange" short-description="Save Party Name Change">
        <!-- for special case in ecommerce, if no partyId is passed in use userLogin.partyId -->
        <if-empty field="parameters.partyId">
            <set field="parameters.partyId" from-field="userLogin.partyId"/>
        </if-empty>

        <make-value value-field="partyNameHistory" entity-name="PartyNameHistory"/>
        <set-pk-fields value-field="partyNameHistory" map="parameters"/>
        <now-timestamp field="partyNameHistory.changeDate"/>

        <if>
            <condition><not><if-empty field="parameters.groupName"/></not></condition>
            <then>
                <entity-one entity-name="PartyGroup" value-field="partyGroup"/>
                <if>
                    <condition><if-compare-field field="partyGroup.groupName" to-field="parameters.groupName" operator="not-equals"/></condition>
                    <then>
                        <set-nonpk-fields value-field="partyNameHistory" map="partyGroup"/>
                        <create-value value-field="partyNameHistory"/>
                    </then>
                </if>
            </then>
            <else-if>
                <condition>
                    <or>
                        <not><if-empty field="parameters.firstName"></if-empty></not>
                        <not><if-empty field="parameters.middleName"></if-empty></not>
                        <not><if-empty field="parameters.lastName"></if-empty></not>
                        <not><if-empty field="parameters.personalTitle"></if-empty></not>
                        <not><if-empty field="parameters.suffix"></if-empty></not>
                    </or>
                </condition>
                <then>
                    <entity-one entity-name="Person" value-field="person"/>
                    <if>
                        <condition>
                            <or>
                                <if-compare-field field="person.firstName" to-field="parameters.firstName" operator="not-equals"/>
                                <if-compare-field field="person.middleName" to-field="parameters.middleName" operator="not-equals"/>
                                <if-compare-field field="person.lastName" to-field="parameters.lastName" operator="not-equals"/>
                                <if-compare-field field="person.personalTitle" to-field="parameters.personalTitle" operator="not-equals"/>
                                <if-compare-field field="person.suffix" to-field="parameters.suffix" operator="not-equals"/>
                            </or>
                        </condition>
                        <then>
                            <set-nonpk-fields value-field="partyNameHistory" map="person"/>
                            <create-value value-field="partyNameHistory"/>
                        </then>
                    </if>
                </then>
            </else-if>
        </if>
    </simple-method>

    <simple-method method-name="getPartyNameForDate" short-description="Get Party Name For Date">
        <entity-and entity-name="PartyNameHistory" list="partyNameHistoryList">
            <field-map field-name="partyId" from-field="parameters.partyId"/>
            <order-by field-name="-changeDate"/>
        </entity-and>
        <entity-one entity-name="Person" value-field="person"/>
        <entity-one entity-name="PartyGroup" value-field="partyGroup"/>
        <if-empty field="parameters.compareDate">
            <now-timestamp field="nowTimestamp"/>
            <set field="parameters.compareDate" from-field="nowTimestamp"/>
        </if-empty>
        <!-- go through the list which is sorted by most recent first and find the oldest (last) one with the changeDate greater than the compareDate -->
        <iterate entry="partyNameHistory" list="partyNameHistoryList">
            <if-compare-field field="partyNameHistory.changeDate" to-field="parameters.compareDate" operator="greater" type="Timestamp">
                <set field="partyNameHistoryCurrent" from-field="partyNameHistory"/>
            </if-compare-field>
        </iterate>

        <if-empty field="partyNameHistoryCurrent">
            <if-not-empty field="person">
                <field-to-result field="person.firstName" result-name="firstName"/>
                <if-not-empty field="person.middleName">
                    <field-to-result field="person.middleName" result-name="middleName"/>
                </if-not-empty>
                <field-to-result field="person.lastName" result-name="lastName"/>
                <if-not-empty field="person.personalTitle">
                    <field-to-result field="person.personalTitle" result-name="personalTitle"/>
                </if-not-empty>
                <if-not-empty field="person.gender">
                    <field-to-result field="person.gender" result-name="gender"/>
                </if-not-empty>
                <if-not-empty field="person.suffix">
                    <field-to-result field="person.suffix" result-name="suffix"/>
                </if-not-empty>


                <if-compare field="parameters.lastNameFirst" operator="equals" value="Y">
                    <set field="fullName" value="${person.personalTitle} ${person.lastName}, ${person.firstName} ${person.middleName} ${person.suffix}"/>
                <else>
                    <set field="fullName" value="${person.personalTitle} ${person.firstName} ${person.middleName} ${person.lastName} ${person.suffix}"/>
                </else>
                </if-compare>
                <field-to-result field="fullName"/>

                <else>
                    <if-not-empty field="partyGroup">
                        <field-to-result field="partyGroup.groupName" result-name="groupName"/>
                        <field-to-result field="partyGroup.groupName" result-name="fullName"/>
                    </if-not-empty>
                </else>
            </if-not-empty>
            <else>
                <!-- partyNameHistoryCurrent has a value -->
                <if-not-empty field="person">
                    <field-to-result field="partyNameHistoryCurrent.firstName" result-name="firstName"/>
                    <if-not-empty field="partyNameHistoryCurrent.middleName">
                        <field-to-result field="partyNameHistoryCurrent.middleName" result-name="middleName"/>
                    </if-not-empty>
                    <field-to-result field="partyNameHistoryCurrent.lastName" result-name="lastName"/>
                    <if-not-empty field="partyNameHistoryCurrent.personalTitle">
                        <field-to-result field="partyNameHistoryCurrent.personalTitle" result-name="personalTitle"/>
                    </if-not-empty>
                    <if-not-empty field="partyNameHistoryCurrent.suffix">
                        <field-to-result field="partyNameHistoryCurrent.suffix" result-name="suffix"/>
                    </if-not-empty>
                    <if-not-empty field="person.gender">
                        <field-to-result field="person.gender" result-name="gender"/>
                    </if-not-empty>


                    <if-compare field="parameters.lastNameFirst" operator="equals" value="Y">
                        <set field="fullName" value="${partyNameHistoryCurrent.personalTitle} ${partyNameHistoryCurrent.lastName}, ${partyNameHistoryCurrent.firstName} ${partyNameHistoryCurrent.middleName} ${partyNameHistoryCurrent.suffix}"/>
                    <else>
                        <set field="fullName" value="${partyNameHistoryCurrent.personalTitle} ${partyNameHistoryCurrent.firstName} ${partyNameHistoryCurrent.middleName} ${partyNameHistoryCurrent.lastName} ${partyNameHistoryCurrent.suffix}"/>
                    </else>
                    </if-compare>
                    <field-to-result field="fullName"/>

                    <else>
                        <if-not-empty field="partyGroup">
                            <field-to-result field="partyNameHistoryCurrent.groupName" result-name="groupName"/>
                            <field-to-result field="partyNameHistoryCurrent.groupName" result-name="fullName"/>
                        </if-not-empty>
                    </else>
                </if-not-empty>
            </else>
        </if-empty>
    </simple-method>

    <!-- PostalAddressBoundary methods -->
    <simple-method method-name="getPostalAddressBoundary" short-description="Get Postal Address Boundary">
        <make-value entity-name="PostalAddressBoundary" value-field="postalAddressBoundaryLookupMap"/>
        <set field="postalAddressBoundaryLookupMap.geoId" from-field="parameters.geoId"/>
        <find-by-and entity-name="PostalAddressBoundary" map="postalAddressBoundaryLookupMap" list="postalAddressBoundaries"/>
        <iterate list="postalAddressBoundaries" entry="postalAddressBoundary">
            <get-related-one value-field="postalAddressBoundary" to-value-field="geo" relation-name="Geo"/>
            <field-to-list field="geo" list="geos"/>
        </iterate>
        <field-to-result field="geos"/>
    </simple-method>
    
    <!-- PartyIdentification methods -->
    <simple-method method-name="createPartyIdentifications" short-description="create mass party identification with association between value and type">
        <set field="partyIdentCtx.partyId" from-field="parameters.partyId"/>
        <iterate-map key="key" value="value" map="parameters.identifications">
            <entity-one value-field="identificationType" entity-name="PartyIdentificationType" use-cache="true">
                <field-map field-name="partyIdentificationTypeId" from-field="value"/>
            </entity-one>
            <if-not-empty field="identificationType">
                <set field="idValue" value="${parameters.identifications.${identificationType.partyIdentificationTypeId}}"/>
                <if-not-empty field="idValue">
                    <set field="partyIdentCtx.partyIdentificationTypeId" from-field="identificationType.partyIdentificationTypeId"/>
                    <set field="partyIdentCtx.idValue" from-field="idValue"/>
                    <call-service service-name="createPartyIdentification" in-map-name="partyIdentCtx"/>
                </if-not-empty> 
            </if-not-empty>
        </iterate-map>
    </simple-method>

    <!-- party profile default -->
    <simple-method method-name="setPartyProfileDefaults" short-description="Sets Party Profile Defaults">
        <if-empty field="parameters.partyId">
            <set from-field="userLogin.partyId" field="parameters.partyId"/>
        </if-empty>

        <!-- lookup existing value -->
        <entity-one entity-name="PartyProfileDefault" value-field="partyProfileDefault"/>
        <if-empty field="partyProfileDefault">
            <make-value value-field="partyProfileDefault" entity-name="PartyProfileDefault"/>
            <set-pk-fields value-field="partyProfileDefault" map="parameters"/>
            <create-value value-field="partyProfileDefault"/>
        </if-empty>

        <!-- update the fields -->
        <set-nonpk-fields value-field="partyProfileDefault" map="parameters" set-if-null="false"/>
        <store-value value-field="partyProfileDefault"/>
    </simple-method>

    <!-- create party content -->
    <!-- TODO: this method will be deleted in favor of new content methods and the PartyContentServices.xml -->
    <simple-method method-name="createPartyContent" short-description="Creates Party Associated Content" login-required="false">
           <!-- make sure we are logged in when passing a partyId -->
        <if-not-empty field="parameters.partyId">
            <if-empty field="parameters.userLogin">
                <add-error><fail-property resource="PartyUiLabels" property="PartyPermissionErrorForThisParty"/></add-error>
                <check-errors/>
            </if-empty>
        </if-not-empty>

        <!-- check permission when creating content on behalf of another party -->
        <if-empty field="parameters.partyId">
            <if-not-empty field="parameters.userLogin">
                <set from-field="userLogin.partyId" field="parameters.partyId"/>
                <if-compare-field to-field="userLogin.partyId" field="parameters.partyId" operator="not-equals">
                    <check-permission permission="PARTYMGR" action="_UPDATE">
                        <fail-property resource="PartyUiLabels" property="PartyPermissionErrorForThisParty"/>
                    </check-permission>
                </if-compare-field>
            </if-not-empty>
        </if-empty>
       <if-not-empty field="parameters._uploadedFile_fileName">
           <set field="absolute" value="true" type="Boolean"/>
           <call-class-method method-name="getDataResourceContentUploadPath" class-name="org.ofbiz.content.data.DataResourceWorker" ret-field="uploadPath">
               <field field="delegator" type="org.ofbiz.entity.Delegator"/>
               <field field="absolute" type="boolean"/>
           </call-class-method>
           <log level="always" message="[createPartyContent] - Found Subdir : ${uploadPath}"/>
           <!-- locate the file extension to use based on mime-type -->
           <set from-field="parameters._uploadedFile_contentType" field="extenLookup.mimeTypeId"/>
           <find-by-and entity-name="FileExtension" map="extenLookup" list="extensions"/>
           <first-from-list entry="extension" list="extensions"/>
           <set-service-fields service-name="createDataResource" map="parameters" to-map="dataResource"/>
           <!-- create the data resource object -->
           <set from-field="parameters._uploadedFile_fileName" field="dataResource.dataResourceName"/>
           <set from-field="parameters._uploadedFile_contentType" field="dataResource.mimeTypeId"/>
           <set value="LOCAL_FILE" field="dataResource.dataResourceTypeId"/>
           <call-service service-name="createDataResource" in-map-name="dataResource" break-on-error="false">
               <result-to-field result-name="dataResourceId" field="dataResourceId"/>
           </call-service>

           <set-service-fields service-name="updateDataResource" map="dataResource" to-map="dataResource"/>
           <set from-field="dataResourceId" field="dataResource.dataResourceId"/>
           <call-service service-name="updateDataResource" in-map-name="dataResource" break-on-error="false"/>
           <set from-field="dataResource.dataResourceId" field="lookup.dataResourceId"/>
           <find-by-primary-key use-cache="true" entity-name="DataResource" value-field="dataResourceMap" map="lookup"/>
       </if-not-empty>

       <set-service-fields service-name="createContent" map="parameters" to-map="createContentMap"/>
       <if-not-empty field="parameters._uploadedFile_fileName">
            <set from-field="dataResourceId" field="createContentMap.dataResourceId"/>
       </if-not-empty>
       <call-service service-name="createContent" in-map-name="createContentMap" break-on-error="false">
            <result-to-field result-name="contentId" field="contentId"/>
       </call-service>
       <!-- create the content role -->
       <if-not-empty field="parameters.partyId">
            <now-timestamp field="nowTimestamp"/>
            <set-service-fields service-name="createContentRole" map="parameters" to-map="contentRole"/>
            <set from-field="contentId" field="contentRole.contentId"/>
            <set from-field="parameters.partyId" field="contentRole.partyId"/>
            <set from-field="nowTimestamp" field="contentRole.fromDate"/>
            <set value="OWNER" field="contentRole.roleTypeId"/>
            <call-service service-name="createContentRole" in-map-name="contentRole" break-on-error="false"/>
            <!-- check party role -->
            <make-value value-field="partyRole" entity-name="PartyRole"/>
            <set-pk-fields value-field="partyRole" map="contentRole"/>
            <find-by-and entity-name="PartyRole" map="partyRole" list="pRoles"/>
            <if-empty field="pRoles">
                <set-service-fields service-name="createPartyRole" map="contentRole" to-map="partyRole"/>
                <call-service service-name="createPartyRole" in-map-name="partyRole" break-on-error="false"/>
            </if-empty>
       </if-not-empty>
       <if-not-empty field="parameters._uploadedFile_fileName">
            <!-- store the file -->
            <set-service-fields service-name="createAnonFile" map="dataResourceMap" to-map="fileCtx"/>
            <set from-field="parameters.uploadedFile" field="fileCtx.binData"/>
            <set from-field="dataResourceMap" field="fileCtx.dataResource"/>
            <call-service service-name="createAnonFile" in-map-name="fileCtx" include-user-login="true"/>
        </if-not-empty>
       <field-to-result field="contentId"/>
    </simple-method>

    <!-- Update party content -->
    <!-- TODO: this method will be deleted in favor of new content methods and the PartyContentServices.xml -->
    <simple-method method-name="updatePartyContent" short-description="Creates Party Associated Content" login-required="false">
           <!-- make sure we are logged in when passing a partyId -->
        <if-not-empty field="parameters.partyId">
            <if-empty field="parameters.userLogin">
                <add-error><fail-property resource="PartyUiLabels" property="PartyPermissionErrorForThisParty"/></add-error>
                <check-errors/>
            </if-empty>
        </if-not-empty>

        <!-- check permission when creating content on behalf of another party -->
        <if-empty field="parameters.partyId">
            <if-not-empty field="parameters.userLogin">
                <set from-field="userLogin.partyId" field="parameters.partyId"/>
                <if-compare-field to-field="userLogin.partyId" field="parameters.partyId" operator="not-equals">
                    <check-permission permission="PARTYMGR" action="_UPDATE">
                        <fail-property resource="PartyUiLabels" property="PartyPermissionErrorForThisParty"/>
                    </check-permission>
                </if-compare-field>
            </if-not-empty>
        </if-empty>

        <if-not-empty field="parameters._uploadedFile_fileName">
           <set from-field="parameters.contentId" field="lookupParam.contentId"/>
           <find-by-primary-key use-cache="true" entity-name="Content" value-field="content" map="lookupParam"/>
           <if-not-empty field="content.dataResourceId">
               <set-service-fields service-name="updateDataResource" map="parameters" to-map="dataResource"/>
               <set from-field="content.dataResourceId" field="dataResource.dataResourceId"/>
               <call-service service-name="updateDataResource" in-map-name="dataResource" break-on-error="false"/>
               <set from-field="content.dataResourceId" field="lookup.dataResourceId"/>
               <find-by-primary-key use-cache="true" entity-name="DataResource" value-field="dataResourceMap" map="lookup"/>
            <else>
               <set field="absolute" value="true" type="Boolean"/>
               <call-class-method method-name="getDataResourceContentUploadPath" class-name="org.ofbiz.content.data.DataResourceWorker" ret-field="uploadPath">
                   <field field="delegator" type="org.ofbiz.entity.Delegator"/>
                   <field field="absolute" type="boolean"/>
               </call-class-method>
               <log level="always" message="[createPartyContent] - Found Subdir : ${uploadPath}"/>
               <!-- locate the file extension to use based on mime-type -->
               <set from-field="parameters._uploadedFile_contentType" field="extenLookup.mimeTypeId"/>
               <find-by-and entity-name="FileExtension" map="extenLookup" list="extensions"/>
               <first-from-list entry="extension" list="extensions"/>
               <set-service-fields service-name="createDataResource" map="parameters" to-map="dataResource"/>
               <!-- create the data resource object -->
                <!-- create the data resource object -->
                <set from-field="parameters._uploadedFile_fileName" field="dataResource.dataResourceName"/>
                <set from-field="parameters._uploadedFile_contentType" field="dataResource.mimeTypeId"/>
                <set value="LOCAL_FILE" field="dataResource.dataResourceTypeId"/>
                <call-service service-name="createDataResource" in-map-name="dataResource" break-on-error="false">
                    <result-to-field result-name="dataResourceId" field="dataResourceId"/>
                </call-service>
                <set value="${uploadPath}/${dataResourceId}" field="dataResource.objectInfo"/>
                <if-not-empty field="extension">
                    <set value="${uploadPath}/${dataResourceId}.${extension.fileExtensionId}" field="dataResource.objectInfo"/>
                </if-not-empty>
                <set-service-fields service-name="updateDataResource" map="dataResource" to-map="dataResource"/>
                <set from-field="dataResourceId" field="dataResource.dataResourceId"/>
                <call-service service-name="updateDataResource" in-map-name="dataResource" break-on-error="false"/>
                <set from-field="dataResource.dataResourceId" field="lookup.dataResourceId"/>
                <find-by-primary-key use-cache="true" entity-name="DataResource" value-field="dataResourceMap" map="lookup"/>
            </else>
           </if-not-empty>
       </if-not-empty>
       <set-service-fields service-name="updateContent" map="parameters" to-map="updateContentMap"/>
       <if-not-empty field="dataResourceId">
           <set from-field="dataResourceId" field="updateContentMap.dataResourceId"/>
       </if-not-empty>
       <call-service service-name="updateContent" in-map-name="updateContentMap" break-on-error="false"/>
       <if-not-empty field="parameters._uploadedFile_fileName">
          <set-service-fields service-name="createAnonFile" map="dataResourceMap" to-map="fileCtx"/>
          <set from-field="parameters.uploadedFile" field="fileCtx.binData"/>
          <set from-field="dataResourceMap" field="fileCtx.dataResource"/>
          <call-service service-name="createAnonFile" in-map-name="fileCtx" include-user-login="true"/>
      </if-not-empty>
        <field-to-result  field="parameters.contentId" result-name="contentId"/>
    </simple-method>

    <!-- get parties based on PartyRelationship -->
    <simple-method method-name="getPartiesByRelationship"
            short-description="Gets all parties related to partyIdFrom using the PartyRelationship entity" login-required="false">
        <set from-field="parameters.partyIdFrom" field="lookupMap.partyIdFrom"/>
        <set from-field="parameters.partyIdTo" field="lookupMap.partyIdTo"/>
        <set from-field="parameters.roleTypeIdFrom" field="lookupMap.roleTypeIdFrom"/>
        <set from-field="parameters.roleTypeIdTo" field="lookupMap.roleTypeIdTo"/>
        <set from-field="parameters.statusId" field="lookupMap.statusId"/>
        <set from-field="parameters.priorityTypeId" field="lookupMap.priorityTypeId"/>
        <set from-field="parameters.partyRelationshipTypeId" field="lookupMap.partyRelationshipTypeId"/>

        <find-by-and entity-name="PartyRelationship" map="lookupMap" list="partyRelationships"/>
        <iterate list="partyRelationships" entry="partyRelationship">
            <get-related-one value-field="partyRelationship" relation-name="ToParty" to-value-field="party"/>
            <field-to-list field="party" list="parties"/>
        </iterate>
        <if-not-empty field="parties">
            <field-to-result field="parties"/>
        </if-not-empty>
    </simple-method>

    <simple-method method-name="getParentOrganizations" short-description="Gets Parent Organizations for an Organization Party">
        <set from-field="parameters.organizationPartyId" field="relatedPartyIdList[]"/>
        <set from-field="parameters.getParentsOfParents" field="recurse"/>
        <if-empty field="recurse"><set value="Y" field="recurse"/></if-empty>

        <set value="GROUP_ROLLUP" field="partyRelationshipTypeId"/>
        <set value="ORGANIZATION_UNIT" field="roleTypeIdFrom"/>
        <set value="PARENT_ORGANIZATION" field="roleTypeIdTo"/>
        <set value="Y" field="roleTypeIdFromInclueAllChildTypes"/>

        <set value="Y" field="includeFromToSwitched"/>
        <set value="true" field="useCache"/>

        <call-simple-method method-name="followPartyRelationshipsInline"/>

        <field-to-result field="relatedPartyIdList" result-name="parentOrganizationPartyIdList"/>
    </simple-method>

    <simple-method method-name="getRelatedParties" short-description="Get Parties Related to a Party">
        <set from-field="parameters.partyIdFrom" field="relatedPartyIdList[]"/>
        <set from-field="parameters.partyRelationshipTypeId" field="partyRelationshipTypeId"/>
        <set from-field="parameters.roleTypeIdFrom" field="roleTypeIdFrom"/>
        <set from-field="parameters.roleTypeIdFromInclueAllChildTypes" field="roleTypeIdFromInclueAllChildTypes"/>
        <set from-field="parameters.roleTypeIdTo" field="roleTypeIdTo"/>
        <set from-field="parameters.roleTypeIdToIncludeAllChildTypes" field="roleTypeIdToIncludeAllChildTypes"/>
        <set from-field="parameters.includeFromToSwitched" field="includeFromToSwitched"/>
        <set from-field="parameters.recurse" field="recurse"/>
        <set from-field="parameters.useCache" field="useCache"/>

        <call-simple-method method-name="followPartyRelationshipsInline"/>

        <field-to-result field="relatedPartyIdList"/>
    </simple-method>

    <simple-method method-name="followPartyRelationshipsInline" short-description="followPartyRelationshipsInline">
        <!--
            Uses the following fields in the env (with * are required):
             - relatedPartyIdList* (initial partyIdFrom should be in this list; accumulator of new partyIds, ie all partyIdTo found will be added to this, thus can support recursion)
             - partyRelationshipTypeId
             - roleTypeIdFrom
             - roleTypeIdFromInclueAllChildTypes
             - roleTypeIdTo
             - roleTypeIdToIncludeAllChildTypes
             - includeFromToSwitched
             - recurse
             - useCache (should be "true" or "false")
        -->

        <if-empty field="nowTimestamp"><now-timestamp field="nowTimestamp"/></if-empty>

        <!-- only create these if they don't already exist, more efficient and avoids potential problems in recursed calls -->
        <if-empty field="_inline_roleTypeIdFromList">
            <field-to-list field="roleTypeIdFrom" list="_inline_roleTypeIdFromList"/>
            <if-compare field="roleTypeIdFromInclueAllChildTypes" operator="equals" value="Y">
                <set value="_inline_roleTypeIdFromList" field="roleTypeIdListName"/>
                <call-simple-method method-name="getChildRoleTypesInline"/>
            </if-compare>
        </if-empty>
        <if-empty field="_inline_roleTypeIdToList">
            <field-to-list field="roleTypeIdTo" list="_inline_roleTypeIdToList"/>
            <if-compare field="roleTypeIdToInclueAllChildTypes" operator="equals" value="Y">
                <set value="_inline_roleTypeIdToList" field="roleTypeIdListName"/>
                <call-simple-method method-name="getChildRoleTypesInline"/>
            </if-compare>
        </if-empty>

        <call-simple-method method-name="followPartyRelationshipsInlineRecurse"/>
    </simple-method>
    <simple-method method-name="followPartyRelationshipsInlineRecurse" short-description="followPartyRelationshipsInlineRecurse">
        <clear-field field="_inline_NewRelatedPartyIdList"/>

        <iterate entry="relatedPartyId" list="relatedPartyIdList">
            <if>
                <condition><not><if-compare-field field="_inline_relatedPartyIdAlreadySearchedList" to-field="relatedPartyId" operator="contains"/></not></condition>
                <then>
                    <field-to-list field="relatedPartyId" list="_inline_relatedPartyIdAlreadySearchedList"/>

                    <clear-field field="_inline_PartyRelationshipList"/>
                    <entity-condition entity-name="PartyRelationship" list="_inline_PartyRelationshipList" use-cache="${useCache}">
                        <condition-list combine="and">
                            <condition-expr field-name="partyIdFrom" from-field="relatedPartyId"/>
                            <condition-expr field-name="roleTypeIdFrom" operator="in" from-field="_inline_roleTypeIdFromList" ignore-if-empty="true"/>
                            <condition-expr field-name="roleTypeIdTo" operator="in" from-field="_inline_roleTypeIdToList" ignore-if-empty="true"/>
                            <condition-expr field-name="partyRelationshipTypeId" from-field="partyRelationshipTypeId" ignore-if-empty="true"/>

                            <condition-expr field-name="fromDate" operator="less-equals" from-field="nowTimestamp"/>
                            <condition-list combine="or">
                                <condition-expr field-name="thruDate" operator="equals" from-field="nullField"/>
                                <condition-expr field-name="thruDate" operator="greater" from-field="nowTimestamp"/>
                            </condition-list>
                        </condition-list>

                        <!-- get the newest (highest date) first -->
                        <order-by field-name="-fromDate"/>
                    </entity-condition>
                    <iterate entry="_inline_PartyRelationship" list="_inline_PartyRelationshipList">
                        <if>
                            <condition>
                                <and>
                                    <not><if-compare-field field="relatedPartyIdList" to-field="_inline_PartyRelationship.partyIdTo" operator="contains"/></not>
                                    <not><if-compare-field field="_inline_NewRelatedPartyIdList" to-field="_inline_PartyRelationship.partyIdTo" operator="contains"/></not>
                                </and>
                            </condition>
                            <then>
                                <field-to-list field="_inline_PartyRelationship.partyIdTo" list="_inline_NewRelatedPartyIdList"/>
                            </then>
                        </if>
                    </iterate>

                    <if-compare field="includeFromToSwitched" operator="equals" value="Y">
                        <clear-field field="_inline_PartyRelationshipList"/>
                        <entity-condition entity-name="PartyRelationship" list="_inline_PartyRelationshipList" use-cache="${useCache}">
                            <condition-list combine="and">
                                <condition-expr field-name="partyIdTo" from-field="relatedPartyId"/>
                                <condition-expr field-name="roleTypeIdTo" operator="in" from-field="_inline_roleTypeIdFromList" ignore-if-empty="true"/>
                                <condition-expr field-name="roleTypeIdFrom" operator="in" from-field="_inline_roleTypeIdToList" ignore-if-empty="true"/>
                                <condition-expr field-name="partyRelationshipTypeId" from-field="partyRelationshipTypeId" ignore-if-empty="true"/>

                                <condition-expr field-name="fromDate" operator="less-equals" from-field="nowTimestamp"/>
                                <condition-list combine="or">
                                    <condition-expr field-name="thruDate" operator="equals" from-field="nullField"/>
                                    <condition-expr field-name="thruDate" operator="greater" from-field="nowTimestamp"/>
                                </condition-list>
                            </condition-list>

                            <!-- get the newest (highest date) first -->
                            <order-by field-name="-fromDate"/>
                        </entity-condition>
                        <iterate entry="_inline_PartyRelationship" list="_inline_PartyRelationshipList">
                            <if>
                                <condition>
                                    <and>
                                        <not><if-compare-field field="relatedPartyIdList" to-field="_inline_PartyRelationship.partyIdFrom" operator="contains"/></not>
                                        <not><if-compare-field field="_inline_NewRelatedPartyIdList" to-field="_inline_PartyRelationship.partyIdFrom" operator="contains"/></not>
                                    </and>
                                </condition>
                                <then>
                                    <field-to-list field="_inline_PartyRelationship.partyIdFrom" list="_inline_NewRelatedPartyIdList"/>
                                </then>
                            </if>
                        </iterate>
                    </if-compare>
                </then>
            </if>
        </iterate>

        <!-- if we found new ones, add them to the master list and if recurse=Y then recurse -->
        <if-not-empty field="_inline_NewRelatedPartyIdList">
            <list-to-list list="_inline_NewRelatedPartyIdList" to-list="relatedPartyIdList"/>
            <if-compare field="recurse" operator="equals" value="Y">
                <log level="verbose" message="Recursively calling followPartyRelationshipsInlineRecurse _inline_NewRelatedPartyIdList=${_inline_NewRelatedPartyIdList}"/>
                <call-simple-method method-name="followPartyRelationshipsInlineRecurse"/>
            </if-compare>
        </if-not-empty>
    </simple-method>

    <simple-method method-name="getChildRoleTypes" short-description="Get Child RoleTypes">
        <field-to-list field="roleTypeId" list="childRoleTypeIdList"/>
        <set value="childRoleTypeIdList" field="roleTypeIdListName"/>
        <call-simple-method method-name="getChildRoleTypesInline"/>
        <field-to-result field="childRoleTypeIdList"/>
    </simple-method>
    <simple-method method-name="getChildRoleTypesInline" short-description="getChildRoleTypes">
        <clear-field field="_inline_NewRoleTypeIdList"/>

        <iterate entry="roleTypeId" list="${roleTypeIdListName}">
            <if>
                <condition><not><if-compare-field field="_inline_roleTypeIdAlreadySearchedList" to-field="roleTypeId" operator="contains"/></not></condition>
                <then>
                    <field-to-list field="roleTypeId" list="_inline_roleTypeIdAlreadySearchedList"/>

                    <clear-field field="_inline_RoleTypeList"/>
                    <entity-condition entity-name="RoleType" list="_inline_RoleTypeList" use-cache="true">
                        <condition-expr field-name="parentTypeId" operator="equals" from-field="roleTypeId"/>
                    </entity-condition>
                    <iterate entry="newRoleType" list="_inline_RoleTypeList">
                        <if>
                            <condition>
                                <and>
                                    <not><if-compare-field field="${roleTypeIdListName}" to-field="newRoleType.roleTypeId" operator="contains"/></not>
                                    <not><if-compare-field field="_inline_NewRoleTypeIdList" to-field="newRoleType.roleTypeId" operator="contains"/></not>
                                </and>
                            </condition>
                            <then>
                                <field-to-list field="newRoleType.roleTypeId" list="_inline_NewRoleTypeIdList"/>
                            </then>
                        </if>
                    </iterate>
                </then>
            </if>
        </iterate>

        <!-- if we found some new types, add them to the main list -->
        <if-not-empty field="_inline_NewRoleTypeIdList">
            <list-to-list list="_inline_NewRoleTypeIdList" to-list="${roleTypeIdListName}"/>
            <log level="verbose" message="Recursively calling getChildRoleTypesInline roleTypeIdListName=${roleTypeIdListName}, _inline_NewRoleTypeIdList=${_inline_NewRoleTypeIdList}"/>
            <call-simple-method method-name="getChildRoleTypesInline"/>
        </if-not-empty>
    </simple-method>

    <simple-method method-name="getPartyEmail" short-description="Get the email of the party">
        <!-- first try to find primary email Address when not found get other email -->
        <entity-and entity-name="PartyContactWithPurpose" list="emailAddressesPurposes">
            <field-map field-name="partyId" from-field="parameters.partyId"/>
            <field-map field-name="contactMechPurposeTypeId" from-field="parameters.contactMechPurposeTypeId"/>
        </entity-and>
        <filter-list-by-date list="emailAddressesPurposes" to-list="emailAddressesPurposes1" from-field-name="purposeFromDate" thru-field-name="purposeThruDate"/>
        <filter-list-by-date list="emailAddressesPurposes1" to-list="emailAddresses" from-field-name="contactFromDate" thru-field-name="contactThruDate"/>
        <!-- any other email -->
        <if-empty field="emailAddresses">
            <entity-and entity-name="PartyAndContactMech" list="emailAddresses" filter-by-date="true">
                <field-map field-name="partyId" from-field="parameters.partyId"/>
                <field-map field-name="contactMechTypeId" value="EMAIL_ADDRESS"/>
            </entity-and>
        </if-empty> 
        <!-- any other electronic address -->
        <if-empty field="emailAddresses">
            <entity-and entity-name="PartyAndContactMech" list="emailAddresses" filter-by-date="true">
                <field-map field-name="partyId" from-field="parameters.partyId"/>
                <field-map field-name="contactMechTypeId" value="ELECTRONIC_ADDRESS"/>
            </entity-and>
        </if-empty>
        <if-not-empty field="emailAddresses">
            <first-from-list entry="emailAddress" list="emailAddresses"/>
            <field-to-result field="emailAddress.infoString" result-name="emailAddress"/>
            <field-to-result field="emailAddress.contactMechId" result-name="contactMechId"/>
        </if-not-empty>
    </simple-method>

    <simple-method method-name="getPartyTelephone" short-description="Get the telephone number of the party">
        <set field="findMap.partyId" from-field="parameters.partyId"/>
        <if-empty field="parameters.contactMechPurposeTypeId">
            <!-- search in this order if not provided-->
            <set field="type" value="PRIMARY_PHONE"/><field-to-list field="type" list="types"/>
            <set field="type" value="PHONE_MOBILE"/><field-to-list field="type" list="types"/>
            <set field="type" value="PHONE_WORK"/><field-to-list field="type" list="types"/>
            <set field="type" value="PHONE_QUICK"/><field-to-list field="type" list="types"/>
            <set field="type" value="PHONE_HOME"/><field-to-list field="type" list="types"/>
            <set field="type" value="PHONE_BILLING"/><field-to-list field="type" list="types"/>
            <set field="type" value="PHONE_SHIPPING"/><field-to-list field="type" list="types"/>
            <set field="type" value="PHONE_SHIP_ORIG"/><field-to-list field="type" list="types"/>
            <else>
                <set field="type" from-field="parameters.contactMechPurposeTypeId"/>
                <field-to-list field="type" list="types"/>
            </else>
        </if-empty>
        <set field="findMap.contactMechTypeId" value="TELECOM_NUMBER"/>
        <find-by-and entity-name="PartyContactDetailByPurpose" map="findMap" list="telephoneAll1"/>
        <filter-list-by-date list="telephoneAll1" to-list="telephoneAll2" from-field-name="purposeFromDate" thru-field-name="purposeThruDate"/>
        <filter-list-by-date list="telephoneAll2" to-list="telephoneAll3"/>
        <if-not-empty field="telephoneAll3">
            <iterate entry="type" list="types">
                <iterate entry="telephone" list="telephoneAll3">
                    <if-empty field="found">
                        <if-compare-field field="telephone.contactMechPurposeTypeId" to-field="type" operator="equals">
                            <set field="found" value="notImportant"/>
                            <field-to-result field="telephone.contactMechId" result-name="contactMechId"/>
                            <if-not-empty field="telephone.countryCode">
                                <field-to-result field="telephone.countryCode" result-name="countryCode"/>
                            </if-not-empty>
                            <if-not-empty field="telephone.areaCode">
                                <field-to-result field="telephone.areaCode" result-name="areaCode"/>
                            </if-not-empty>
                            <if-not-empty field="telephone.contactNumber">
                                <field-to-result field="telephone.contactNumber" result-name="contactNumber"/>
                            </if-not-empty>
                            <if-not-empty field="telephone.extension">
                                <field-to-result field="telephone.extension" result-name="extension"/>
                            </if-not-empty>
                            <field-to-result field="telephone.contactMechPurposeTypeId" result-name="contactMechPurposeTypeId"/>
                        </if-compare-field>
                    </if-empty>
                </iterate>
            </iterate>
            <else>
                <find-by-and entity-name="PartyAndContactMech" map="findMap" list="telephoneAll1"/>
                <filter-list-by-date list="telephoneAll1" to-list="telephoneAll2"/>
                <first-from-list entry="telephone" list="telephoneAll2"/>
                <field-to-result field="telephone.contactMechId" result-name="contactMechId"/>
                <if-not-empty field="telephone.tnCountryCode">
                    <field-to-result field="telephone.tnCountryCode" result-name="countryCode"/>
                </if-not-empty>
                <if-not-empty field="telephone.tnAreaCode">
                    <field-to-result field="telephone.tnAreaCode" result-name="areaCode"/>
                </if-not-empty>
                <if-not-empty field="telephone.tnContactNumber">
                    <field-to-result field="telephone.tnContactNumber" result-name="contactNumber"/>
                </if-not-empty>
                <if-not-empty field="telephone.extension">
                    <field-to-result field="telephone.extension" result-name="extension"/>
                </if-not-empty>
            </else>
        </if-not-empty>
    </simple-method>

    <simple-method method-name="getPartyPostalAddress" short-description="Get the postal address of the party">
        <set field="findMap.partyId" from-field="parameters.partyId"/>
        <if-empty field="parameters.contactMechPurposeTypeId">
                <!-- search in this order if not provided-->
                <set field="type" value="GENERAL_LOCATION"/><field-to-list field="type" list="types"/>
                <set field="type" value="BILLING_LOCATION"/><field-to-list field="type" list="types"/>
                <set field="type" value="PAYMENT_LOCATION"/><field-to-list field="type" list="types"/>
                <set field="type" value="SHIPPING_LOCATION"/><field-to-list field="type" list="types"/>
                <else>
                    <set field="type" from-field="parameters.contactMechPurposeTypeId"/><field-to-list field="type" list="types"/>
                </else>
        </if-empty>
        <set field="findMap.contactMechTypeId" value="POSTAL_ADDRESS"/>
        <find-by-and entity-name="PartyContactDetailByPurpose" map="findMap" list="addressAll1"></find-by-and>
        <filter-list-by-date list="addressAll1" to-list="addressAll2" from-field-name="purposeFromDate" thru-field-name="purposeThruDate"/>
        <filter-list-by-date list="addressAll2" to-list="addressAll3"/>
        <if-not-empty field="addressAll3">
            <iterate entry="type" list="types">
                <iterate entry="address" list="addressAll3">
                    <if-empty field="found">
                        <if-compare-field field="address.contactMechPurposeTypeId" to-field="type" operator="equals">
                            <set field="found" value="notImportant"/>
                            <field-to-result field="address.contactMechId" result-name="contactMechId"/>
                            <if-not-empty field="address.address1">
                                <field-to-result field="address.address1" result-name="address1"/>
                            </if-not-empty>
                            <if-not-empty field="address.address2">
                                <field-to-result field="address.address2" result-name="address2"/>
                            </if-not-empty>
                            <if-not-empty field="address.directions">
                                <field-to-result field="address.directions" result-name="directions"/>
                            </if-not-empty>
                            <if-not-empty field="address.city">
                                <field-to-result field="address.city" result-name="city"/>
                            </if-not-empty>
                            <if-not-empty field="address.postalCode">
                                <field-to-result field="address.postalCode" result-name="postalCode"/>
                            </if-not-empty>
                            <if-not-empty field="address.stateProvinceGeoId">
                                <field-to-result field="address.stateProvinceGeoId" result-name="stateProvinceGeoId"/>
                            </if-not-empty>
                            <if-not-empty field="address.countyGeoId">
                                <field-to-result field="address.countyGeoId" result-name="countyGeoId"/>
                            </if-not-empty>
                            <if-not-empty field="address.countryGeoId">
                                <field-to-result field="address.countryGeoId" result-name="countryGeoId"/>
                            </if-not-empty>
                            <field-to-result field="address.contactMechPurposeTypeId" result-name="contactMechPurposeTypeId"/>
                        </if-compare-field>
                    </if-empty>
                </iterate>
            </iterate>
            <else>
                <find-by-and entity-name="PartyAndContactMech" map="findMap" list="addressAll1"/>
                <filter-list-by-date list="addressAll1" to-list="addressAll2"/>
                <first-from-list entry="address" list="addressAll2"/>
                      <field-to-result field="address.contactMechId" result-name="contactMechId"/>
                      <if-not-empty field="address.paAddress1">
                          <field-to-result field="address.paAddress1" result-name="address1"/>
                      </if-not-empty>
                      <if-not-empty field="address.paAddress2">
                          <field-to-result field="address.paAddress2" result-name="address2"/>
                      </if-not-empty>
                      <if-not-empty field="address.paDirections">
                          <field-to-result field="address.paDirections" result-name="directions"/>
                      </if-not-empty>
                      <if-not-empty field="address.paCity">
                          <field-to-result field="address.paCity" result-name="city"/>
                      </if-not-empty>
                      <if-not-empty field="address.paPostalCode">
                          <field-to-result field="address.paPostalCode" result-name="postalCode"/>
                      </if-not-empty>
                      <if-not-empty field="address.paStateProvinceGeoId">
                          <field-to-result field="address.paStateProvinceGeoId" result-name="stateProvinceGeoId"/>
                      </if-not-empty>
                      <if-not-empty field="address.paCountyGeoId">
                          <field-to-result field="address.paCountyGeoId" result-name="countyGeoId"/>
                      </if-not-empty>
                      <if-not-empty field="address.paCountryGeoId">
                          <field-to-result field="address.paCountryGeoId" result-name="countryGeoId"/>
                      </if-not-empty>
            </else>
        </if-not-empty>
    </simple-method>

    <!-- address match map -->
    <simple-method method-name="createAddressMatchMap" short-description="create a AddressMatchMap">
        <call-object-method obj-field="parameters.mapValue" method-name="toUpperCase" ret-field="parameters.mapValue"/>
        <call-object-method obj-field="parameters.mapKey" method-name="toUpperCase" ret-field="parameters.mapKey"/>
        <make-value entity-name="AddressMatchMap" value-field="newEntity"/>
        <set-pk-fields map="parameters" value-field="newEntity"/>
        <set-nonpk-fields map="parameters" value-field="newEntity"/>
        <create-value value-field="newEntity"/>
    </simple-method>
    <simple-method method-name="deleteAddressMatchMap" short-description="remove a AddressMatchMap">
        <make-value entity-name="AddressMatchMap" value-field="fieldMap"/>
        <set-pk-fields map="parameters" value-field="fieldMap"/>
        <remove-value value-field="fieldMap"/>
    </simple-method>
    <simple-method method-name="clearAddressMatchMap" short-description="remove all AddressMatchMap">
        <entity-condition entity-name="AddressMatchMap" list="addrs">
            <use-iterator/>
        </entity-condition>
        <iterate entry="addr" list="addrs">
            <remove-value value-field="addr"/>
        </iterate>
    </simple-method>

    <!-- PartyRelationship services -->
    <simple-method method-name="createPartyRelationship" short-description="createPartyRelationship">
        <if-empty field="parameters.roleTypeIdFrom"><set field="parameters.roleTypeIdFrom" value="_NA_"/></if-empty>
        <if-empty field="parameters.roleTypeIdTo"><set field="parameters.roleTypeIdTo" value="_NA_"/></if-empty>
        <if-empty field="parameters.partyIdFrom"><set field="parameters.partyIdFrom" from-field="userLogin.partyId"/></if-empty>

        <if-empty field="parameters.fromDate"><now-timestamp field="parameters.fromDate"/></if-empty>

        <!-- check if not already exist -->
        <entity-and entity-name="PartyRelationship" list="partyRels" filter-by-date="true">
            <field-map field-name="partyIdFrom" from-field="parameters.partyIdFrom"/>
            <field-map field-name="roleTypeIdFrom" from-field="parameters.roleTypeIdFrom"/>
            <field-map field-name="partyIdTo" from-field="parameters.partyIdTo"/>
            <field-map field-name="roleTypeIdTo" from-field="parameters.roleTypeIdTo"/>
        </entity-and>

        <if-empty field="partyRels">
            <make-value value-field="newEntity" entity-name="PartyRelationship"/>
            <set-pk-fields map="parameters" value-field="newEntity"/>
            <set-nonpk-fields map="parameters" value-field="newEntity"/>
            <create-value value-field="newEntity"/>
        </if-empty>
    </simple-method>
    <simple-method method-name="updatePartyRelationship" short-description="updatePartyRelationship">
        <if-empty field="parameters.roleTypeIdFrom"><set field="parameters.roleTypeIdFrom" value="_NA_"/></if-empty>
        <if-empty field="parameters.roleTypeIdTo"><set field="parameters.roleTypeIdTo" value="_NA_"/></if-empty>

        <entity-one entity-name="PartyRelationship" value-field="lookedUpValue"/>
        <set-nonpk-fields map="parameters" value-field="lookedUpValue"/>
        <store-value value-field="lookedUpValue"/>
    </simple-method>
    <simple-method method-name="deletePartyRelationship" short-description="deletePartyRelationship">
        <if-empty field="parameters.roleTypeIdFrom"><set field="parameters.roleTypeIdFrom" value="_NA_"/></if-empty>
        <if-empty field="parameters.roleTypeIdTo"><set field="parameters.roleTypeIdTo" value="_NA_"/></if-empty>

        <entity-one entity-name="PartyRelationship" value-field="lookedUpValue"/>
        <remove-value value-field="lookedUpValue"/>
    </simple-method>

    <simple-method method-name="createPartyRelationshipContactAccount" short-description="create a company/contact relationship and add the related roles">
        <set field="roleMap.partyId" from-field="parameters.accountPartyId"/>
        <set field="roleMap.roleTypeId" value="ACCOUNT"/>
        <entity-one value-field="partyRole" entity-name="PartyRole">
            <field-map field-name="partyId" from-field="roleMap.partyId"/>
            <field-map field-name="roleTypeId" from-field="roleMap.roleTypeId"/>
        </entity-one>
        <if-empty field="partyRole">
            <call-service service-name="createPartyRole" in-map-name="roleMap"/>
        </if-empty>
        <set field="roleMap.partyId" from-field="parameters.contactPartyId"/>
        <set field="roleMap.roleTypeId" value="CONTACT"/>
        <entity-one value-field="partyRole" entity-name="PartyRole">
            <field-map field-name="partyId" from-field="roleMap.partyId"/>
            <field-map field-name="roleTypeId" from-field="roleMap.roleTypeId"/>
        </entity-one>
        <if-empty field="partyRole">
            <call-service service-name="createPartyRole" in-map-name="roleMap"/>
        </if-empty>
        <set field="relMap.partyIdFrom" from-field="parameters.accountPartyId"/>
        <set field="relMap.roleTypeIdFrom" value="ACCOUNT"/>
        <set field="relMap.partyIdTo" from-field="parameters.contactPartyId"/>
        <set field="relMap.roleTypeIdTo" value="CONTACT"/>
        <set field="relMap.partyRelationshipTypeId" value="EMPLOYMENT"/>
        <set field="relMap.comments" from-field="parameters.comments"/> 
        <call-service service-name="createPartyRelationship" in-map-name="relMap"/>
    </simple-method>

    <!-- send party creation email notification -->
    <simple-method method-name="sendCreatePartyEmailNotification" short-description="Notification email on party creation" login-required="false">
        <map-to-map map="parameters" to-map="bodyParameters"/>
        <set field="emailType" value="PARTY_REGIS_CONFIRM"/>
        <set field="productStoreId" from-field="parameters.productStoreId" />
        <if-empty field="productStoreId">
            <log level="warning" message="No productStoreId specified."/>
        </if-empty>
        <entity-one entity-name="ProductStoreEmailSetting" value-field="storeEmail">
            <field-map field-name="emailType"/>
            <field-map field-name="productStoreId"/>
        </entity-one>
        <entity-and list="webSites" entity-name="WebSite">
            <field-map field-name="productStoreId" from-field="storeEmail.productStoreId"/>
        </entity-and>
        <first-from-list entry="webSite" list="webSites"/>
        <if-not-empty field="storeEmail.bodyScreenLocation">
            <entity-one entity-name="Person" value-field="person"/>
            <set field="bodyParameters.person" from-field="person"/>
            <set field="emailParams.bodyParameters" from-field="bodyParameters"/>

            <set field="emailParams.sendTo" from-field="parameters.emailAddress"/>
            <set field="emailParams.subject" from-field="storeEmail.subject"/>
            <set field="emailParams.sendFrom" from-field="storeEmail.fromAddress"/>
            <set field="emailParams.sendCc" from-field="storeEmail.ccAddress"/>
            <set field="emailParams.sendBcc" from-field="storeEmail.bccAddress"/>
            <set field="emailParams.contentType" from-field="storeEmail.contentType"/>
            <set field="emailParams.bodyScreenUri" from-field="storeEmail.bodyScreenLocation"/>
            <set field="emailParams.webSiteId" from-field="webSite.webSiteId"/>
            <set field="emailParams.emailType" from-field="emailType"/>
            <call-service service-name="sendMailFromScreen" in-map-name="emailParams"/>
        </if-not-empty>
    </simple-method>

    <!-- send personal information update email notification -->
    <simple-method method-name="sendUpdatePersonalInfoEmailNotification" short-description="Send the Notification email on personal information updation" login-required="false">
        <map-to-map map="parameters" to-map="bodyParameters"/>
        <set field="productStoreId" from-field="parameters.productStoreId" />
        <if-empty field="productStoreId">
            <log level="warning" message="No productStoreId specified."/>
        </if-empty>
        <entity-one entity-name="ProductStoreEmailSetting" value-field="storeEmail">
            <field-map field-name="emailType" value="UPD_PRSNL_INF_CNFRM"/>
            <field-map field-name="productStoreId"/>
        </entity-one>
        <entity-and list="webSites" entity-name="WebSite">
            <field-map field-name="productStoreId" from-field="storeEmail.productStoreId"/>
        </entity-and>
        <first-from-list entry="webSite" list="webSites"/>
        <if-not-empty field="storeEmail.bodyScreenLocation">
            <if-not-empty field="parameters.updatedUserLogin.partyId">
                <set field="partyId" from-field="parameters.updatedUserLogin.partyId"/>
            <else>
                <set field="partyId" from-field="parameters.partyId"/>
            </else>
            </if-not-empty>
            <entity-condition entity-name="PartyContactDetailByPurpose" list="partyContactDetailByPurposes" filter-by-date="true">
                <condition-list>
                    <condition-expr field-name="contactMechPurposeTypeId" operator="equals" value="PRIMARY_EMAIL"/>
                    <condition-expr field-name="partyId" operator="equals"  from-field="partyId"/>
                </condition-list>
            </entity-condition>
            <first-from-list entry="partyContactDetailByPurpose" list="partyContactDetailByPurposes"/>
            <entity-one entity-name="PartyAndPerson" value-field="partyAndPerson"/>
            <set field="bodyParameters.partyAndPerson" from-field="partyAndPerson"/>
            <set field="contactMechId" from-field="partyContactDetailByPurpose.contactMechId"/>
            <entity-one entity-name="ContactMech" value-field="contactMech"/>
            <set field="emailParams.sendTo" from-field="contactMech.infoString"/>
            <set field="emailParams.subject" from-field="storeEmail.subject"/>
            <set field="emailParams.sendFrom" from-field="storeEmail.fromAddress"/>
            <set field="emailParams.sendCc" from-field="storeEmail.ccAddress"/>
            <set field="emailParams.sendBcc" from-field="storeEmail.bccAddress"/>
            <set field="emailParams.contentType" from-field="storeEmail.contentType"/>
            <set field="emailParams.bodyParameters" from-field="bodyParameters"/>
            <set field="emailParams.bodyScreenUri" from-field="storeEmail.bodyScreenLocation"/>
            <set field="emailParams.webSiteId" from-field="webSite.webSiteId"/>

            <if-not-empty field="emailParams.sendTo">
                <call-service service-name="sendMailFromScreen" in-map-name="emailParams"/>
                <else>
                    <log level="warning" message="Tried to send Update Personal Info Notifcation with no to address; partyId is [${partyId}], subject is: ${emailParams.subject}"/>
                </else>
            </if-not-empty>
        </if-not-empty>
    </simple-method>

    <simple-method method-name="createUpdatePerson" short-description="Create and update a person" login-required="false">
        <call-map-processor xml-resource="component://party/minilang/party/PartyMapProcs.xml"
                processor-name="person" in-map-name="parameters" out-map-name="personMap"/>
        <check-errors/>
        <set field="partyId" from-field="parameters.partyId"/>
        <entity-one entity-name="Party" value-field="party"/>
        <set field="personContext.partyId" from-field="partyId"/>
        <set-service-fields service-name="createPerson" map="personMap" to-map="personContext"/>
        <if-empty field="party">
            <call-service service-name="createPerson" in-map-name="personContext">
                <result-to-field result-name="partyId" field="partyId"/>
            </call-service>
        <else><!-- If party object already exist, update the person record. -->
            <set field="personContext.userLogin" from-field="parameters.userLogin"/>
            <call-service service-name="updatePerson" in-map-name="personContext"/>
        </else>
        </if-empty>
        <field-to-result field="partyId"/>
    </simple-method>

    <simple-method method-name="quickCreateCustomer" short-description="Create customer profile on basis of First Name ,Last Name and Email Address" login-required="false">
        <call-map-processor xml-resource="component://party/minilang/contact/PartyContactMechMapProcs.xml"
                processor-name="person" in-map-name="parameters" out-map-name="personInMap"/>
        <call-map-processor xml-resource="component://party/minilang/contact/PartyContactMechMapProcs.xml"
                processor-name="emailAddress" in-map-name="parameters" out-map-name="emailAddressInMap"/>
        <check-errors/>
        
        <!-- create person  -->
        <call-service service-name="createPerson" in-map-name="personInMap">
            <result-to-field result-name="partyId"/>
            <result-to-result result-name="partyId"/>
        </call-service>

        <!-- Create email address -->
        <entity-one entity-name="UserLogin" value-field="userLogin">
            <field-map field-name="userLoginId" value="system"/>
        </entity-one>
        <set field="emailAddressInMap.partyId" from-field="partyId"/>
        <set field="emailAddressInMap.userLogin" from-field="userLogin"/>
        <set field="emailAddressInMap.contactMechPurposeTypeId" value="PRIMARY_EMAIL"/>
        <call-service service-name="createPartyEmailAddress" in-map-name="emailAddressInMap"/>

        <!-- Signup for Contact List -->
        <if-compare field="parameters.subscribeContactList" operator="equals" value="Y">
            <set field="signUpForContactListMap.partyId" from-field="partyId"/>
            <set field="signUpForContactListMap.contactListId" from-field="parameters.contactListId"/>
            <set field="signUpForContactListMap.email" from-field="parameters.emailAddress"/>
            <call-service service-name="signUpForContactList" in-map-name="signUpForContactListMap"/>
        </if-compare>

        <!-- Create the PartyRole -->
        <set field="createPartyRoleInMap.partyId" from-field="partyId"/>
        <set field="createPartyRoleInMap.roleTypeId" value="CUSTOMER"/>
        <set field="createPartyRoleInMap.userLogin" from-field="userLogin"/>
        <call-service service-name="createPartyRole" in-map-name="createPartyRoleInMap"/>
    </simple-method>

    <simple-method method-name="getPartyMainRole"
        short-description="Get the main role of this party which is a child of the MAIN_ROLE roletypeId">
        <entity-and entity-name="PartyRole" list="partyRoles">
            <field-map field-name="partyId" from-field="parameters.partyId" />
        </entity-and>
        <!-- find the role in the list -->
        <clear-field field="mainRoleTypeId"/>
        <iterate entry="partyRole" list="partyRoles">
            <if-empty field="mainRoleTypeId">
                <entity-and entity-name="RoleTypeIn3Levels" list="roleTypeIn3Levels">
                    <field-map field-name="topRoleTypeId" value="MAIN_ROLE" />
                    <field-map field-name="lowRoleTypeId" from-field="partyRole.roleTypeId" />
                </entity-and>
                <if-not-empty field="roleTypeIn3Levels">
                    <set field="mainRoleTypeId" from-field="partyRole.roleTypeId" />
                </if-not-empty>
            </if-empty>
        </iterate>
        <if-not-empty field="mainRoleTypeId">
            <field-to-result field="mainRoleTypeId" result-name="roleTypeId" />
            <entity-one entity-name="RoleType" value-field="roleType">
                <field-map field-name="roleTypeId" from-field="mainRoleTypeId" />
            </entity-one>
            <field-to-result result-name="description" field="roleType.description" />
        </if-not-empty>
    </simple-method>
    
    <!-- send account activated email notification -->
    <simple-method method-name="sendAccountActivatedEmailNotification" short-description="Notification email on account activated" login-required="false">
        <map-to-map map="parameters" to-map="bodyParameters"/>
        <set field="emailType" value="PRDS_CUST_ACTIVATED"/>
        <set field="productStoreId" from-field="parameters.productStoreId" />
        <entity-one entity-name="ProductStoreEmailSetting" value-field="storeEmail">
            <field-map field-name="emailType"/>
            <field-map field-name="productStoreId"/>
        </entity-one>
        <entity-and list="webSites" entity-name="WebSite">
            <field-map field-name="productStoreId" from-field="storeEmail.productStoreId"/>
        </entity-and>
        <first-from-list entry="webSite" list="webSites"/>
        <if-not-empty field="storeEmail.bodyScreenLocation">
            <entity-one entity-name="UserLogin" value-field="userLoginParty"/>
            <set field="parameters.partyId" from-field="userLoginParty.partyId"/>
            <entity-condition entity-name="PartyContactDetailByPurpose" list="partyContactDetailByPurposes" filter-by-date="true">
                <condition-list>
                    <condition-expr field-name="contactMechPurposeTypeId" operator="equals" value="PRIMARY_EMAIL"/>
                    <condition-expr field-name="partyId" operator="equals"  from-field="parameters.partyId"/>
                </condition-list>
            </entity-condition>
            <first-from-list entry="partyContactDetailByPurpose" list="partyContactDetailByPurposes"/>
            <entity-one entity-name="Person" value-field="person"/>
            <set field="bodyParameters.person" from-field="person"/>
            <set field="emailParams.bodyParameters" from-field="bodyParameters"/>
            <set field="contactMechId" from-field="partyContactDetailByPurpose.contactMechId"/>
            <entity-one entity-name="ContactMech" value-field="contactMech"/>
            <set field="emailParams.sendTo" from-field="contactMech.infoString"/>
            <set field="emailParams.subject" from-field="storeEmail.subject"/>
            <set field="emailParams.sendFrom" from-field="storeEmail.fromAddress"/>
            <set field="emailParams.sendCc" from-field="storeEmail.ccAddress"/>
            <set field="emailParams.sendBcc" from-field="storeEmail.bccAddress"/>
            <set field="emailParams.contentType" from-field="storeEmail.contentType"/>
            <set field="emailParams.bodyScreenUri" from-field="storeEmail.bodyScreenLocation"/>
            <set field="emailParams.webSiteId" from-field="webSite.webSiteId"/>
            <set field="emailParams.emailType" from-field="emailType"/>
            <call-service service-name="sendMailFromScreen" in-map-name="emailParams"/>
        </if-not-empty>
    </simple-method>
</simple-methods>
