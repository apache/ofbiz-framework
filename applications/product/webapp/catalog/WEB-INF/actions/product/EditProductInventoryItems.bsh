/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import java.util.*;
import java.io.*;
import org.ofbiz.entity.*;
import org.ofbiz.entity.condition.*;
import org.ofbiz.base.util.*;
import org.ofbiz.widget.html.*;
import org.ofbiz.securityext.login.*;
import org.ofbiz.product.inventory.InventoryWorker;

//If product is virtual gather summary data from variants
if (product.getString("isVirtual") != null && "Y".equals(product.getString("isVirtual"))) {
    //Get the virtual product feature types
    result = dispatcher.runSync("getProductFeaturesByType", UtilMisc.toMap("productId", productId, "productFeatureApplTypeId", "SELECTABLE_FEATURE"));
    featureTypeIds = result.get("productFeatureTypes");
    //Get the variants
    result = dispatcher.runSync("getAllProductVariants", UtilMisc.toMap("productId", productId));
    variants = result.get("assocProducts");
    variantIterator = variants.iterator();
    variantInventorySummaries = new ArrayList();
    while(variantIterator.hasNext()) {
        variant = variantIterator.next();

        //create a map of each variant id and inventory summary (all facilities)
        inventoryAvailable = dispatcher.runSync("getProductInventoryAvailable", UtilMisc.toMap("productId", variant.get("productIdTo")));

        variantInventorySummary = UtilMisc.toMap("productId", variant.get("productIdTo"), 
            "availableToPromiseTotal", inventoryAvailable.get("availableToPromiseTotal"),
            "quantityOnHandTotal", inventoryAvailable.get("quantityOnHandTotal"));

        //add the applicable features to the map
        featureTypeIdsIterator = featureTypeIds.iterator();
        while (featureTypeIdsIterator.hasNext()) {
            featureTypeId = featureTypeIdsIterator.next();
            result = dispatcher.runSync("getProductFeatures", UtilMisc.toMap("productId", variant.get("productIdTo"), "type", "STANDARD_FEATURE", "distinct", featureTypeId));
            variantFeatures = result.get("productFeatures");
            if (variantFeatures.size() > 0) {
                //there should only be one result in this collection
                variantInventorySummary.put(featureTypeId, variantFeatures.get(0));
            }
        }
        variantInventorySummaries.add(variantInventorySummary);
    }
    context.put("featureTypeIds", featureTypeIds);
    context.put("variantInventorySummaries", variantInventorySummaries);
} else { //Gather information for a non virtual product
    quantitySummaryByFacility = new HashMap();
    manufacturingInQuantitySummaryByFacility = new HashMap();
    manufacturingOutQuantitySummaryByFacility = new HashMap();
    // The warehouse list is selected
    showAllFacilities = parameters.get("showAllFacilities");
    if (showAllFacilities != null && showAllFacilities.equals("Y")) {
        facilityList = delegator.findAll("Facility");
    } else {
        facilityList = delegator.findByAnd("ProductFacility", UtilMisc.toMap("productId", productId));
    }
    facilityIterator = facilityList.iterator();
    dispatcher = request.getAttribute("dispatcher");
    Map contextInput = null;
    Map resultOutput = null;
   
    // inventory quantity summary by facility: For every warehouse the product's atp and qoh 
    // are obtained (calling the "getInventoryAvailableByFacility" service)
    while (facilityIterator.hasNext()) {
        facility = facilityIterator.next();
        contextInput = UtilMisc.toMap("productId", productId, "facilityId", facility.getString("facilityId"));
        resultOutput = dispatcher.runSync("getInventoryAvailableByFacility", contextInput);
        
        quantitySummary = new HashMap();
        quantitySummary.put("facilityId", facility.getString("facilityId"));
        quantitySummary.put("totalQuantityOnHand", resultOutput.get("quantityOnHandTotal"));
        quantitySummary.put("totalAvailableToPromise", resultOutput.get("availableToPromiseTotal"));

        // if the product is a MARKETING_PKG_AUTO, then also get the quantity which can be produced from components
        if ("MARKETING_PKG_AUTO".equals(product.getString("productTypeId"))) {
            contextInput = UtilMisc.toMap("productId",productId, "facilityId", facility.getString("facilityId"));
            resultOutput = dispatcher.runSync("getMktgPackagesAvailable", contextInput);
            quantitySummary.put("mktgPkgQOH", resultOutput.get("quantityOnHandTotal"));
            quantitySummary.put("mktgPkgATP", resultOutput.get("availableToPromiseTotal"));
        }
        
        quantitySummaryByFacility.put(facility.getString("facilityId"), quantitySummary);
    }

    productInventoryItems = delegator.findByAnd("InventoryItem",
            UtilMisc.toMap("productId", productId),
            UtilMisc.toList("facilityId", "-datetimeReceived", "-inventoryItemId"));

    // TODO: get all incoming shipments not yet arrived coming into each facility that this product is in, use a view entity with ShipmentAndItem
    findIncomingShipmentsConds = new LinkedList();

    findIncomingShipmentsConds.add(new EntityExpr("productId", EntityOperator.EQUALS, productId));

    findIncomingShipmentsTypeConds = new LinkedList();
    findIncomingShipmentsTypeConds.add(new EntityExpr("shipmentTypeId", EntityOperator.EQUALS, "INCOMING_SHIPMENT"));
    findIncomingShipmentsTypeConds.add(new EntityExpr("shipmentTypeId", EntityOperator.EQUALS, "PURCHASE_SHIPMENT"));
    findIncomingShipmentsTypeConds.add(new EntityExpr("shipmentTypeId", EntityOperator.EQUALS, "SALES_RETURN"));
    findIncomingShipmentsConds.add(new EntityConditionList(findIncomingShipmentsTypeConds, EntityOperator.OR));

    findIncomingShipmentsStatusConds = new LinkedList();
    findIncomingShipmentsStatusConds.add(new EntityExpr("statusId", EntityOperator.NOT_EQUAL, "SHIPMENT_DELIVERED"));
    findIncomingShipmentsStatusConds.add(new EntityExpr("statusId", EntityOperator.NOT_EQUAL, "SHIPMENT_CANCELLED"));
    findIncomingShipmentsStatusConds.add(new EntityExpr("statusId", EntityOperator.NOT_EQUAL, "PURCH_SHIP_RECEIVED"));
    findIncomingShipmentsConds.add(new EntityConditionList(findIncomingShipmentsStatusConds, EntityOperator.AND));

    findIncomingShipmentsStatusCondition = new EntityConditionList(findIncomingShipmentsConds, EntityOperator.AND);
    incomingShipmentAndItems = delegator.findByCondition("ShipmentAndItem", findIncomingShipmentsStatusCondition, null, UtilMisc.toList("-estimatedArrivalDate"));
    incomingShipmentAndItemIter = incomingShipmentAndItems.iterator();
    while (incomingShipmentAndItemIter.hasNext()) {
        incomingShipmentAndItem = incomingShipmentAndItemIter.next();
        facilityId = incomingShipmentAndItem.getString("destinationFacilityId");

        quantitySummary = quantitySummaryByFacility.get(facilityId);
        if (quantitySummary == null) {
            quantitySummary = new HashMap();
            quantitySummary.put("facilityId", facilityId);
            quantitySummaryByFacility.put(facilityId, quantitySummary);
        }

        incomingShipmentAndItemList = quantitySummary.get("incomingShipmentAndItemList");
        if (incomingShipmentAndItemList == null) {
            incomingShipmentAndItemList = new LinkedList();
            quantitySummary.put("incomingShipmentAndItemList", incomingShipmentAndItemList);
        }

        incomingShipmentAndItemList.add(incomingShipmentAndItem);
    }

    // --------------------
    // Production Runs
    contextInput = UtilMisc.toMap("productId", productId, "userLogin", userLogin);
    resultOutput = dispatcher.runSync("getProductManufacturingSummaryByFacility", contextInput);
    // incoming products
    manufacturingInQuantitySummaryByFacility = resultOutput.get("summaryInByFacility");
    // outgoing products (materials)
    manufacturingOutQuantitySummaryByFacility = resultOutput.get("summaryOutByFacility");

    showEmpty = "true".equals(request.getParameter("showEmpty"));

    // Find oustanding purchase orders for this item. 
    purchaseOrders = InventoryWorker.getOutstandingPurchaseOrders(productId, delegator);

    context.put("productInventoryItems", productInventoryItems);
    context.put("quantitySummaryByFacility", quantitySummaryByFacility);
    context.put("manufacturingInQuantitySummaryByFacility", manufacturingInQuantitySummaryByFacility);
    context.put("manufacturingOutQuantitySummaryByFacility", manufacturingOutQuantitySummaryByFacility);
    context.put("showEmpty", showEmpty);
    context.put("purchaseOrders", purchaseOrders);
}
